Grammar:

Rule 0     S' -> list
Rule 1     list -> list error NEWLINE
Rule 2     list -> list expr NEWLINE
Rule 3     list -> list stmt NEWLINE
Rule 4     list -> list assign NEWLINE
Rule 5     list -> list defn NEWLINE
Rule 6     list -> list NEWLINE
Rule 7     list -> empty
Rule 8     type -> VOID
Rule 9     type -> STRING
Rule 10    type -> FLOAT
Rule 11    type -> INT
Rule 12    assign -> ID MODEQ expr  [precedence=right, level=1]
Rule 13    assign -> ID DIVEQ expr  [precedence=right, level=1]
Rule 14    assign -> ID MULEQ expr  [precedence=right, level=1]
Rule 15    assign -> ID SUBEQ expr  [precedence=right, level=1]
Rule 16    assign -> ID ADDEQ expr  [precedence=right, level=1]
Rule 17    assign -> ID ASSIGN expr  [precedence=right, level=1]
Rule 18    defn -> PROC procname LPAREN formalopt RPAREN stmt
Rule 19    defn -> FUNC procname LPAREN formalopt RPAREN type stmt
Rule 20    stmt -> LBRACKET stmtlist RBRACKET
Rule 21    stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end
Rule 22    stmt -> IF LPAREN cond RPAREN stmt end
Rule 23    stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end
Rule 24    stmt -> WHILE LPAREN cond RPAREN stmt end
Rule 25    stmt -> PRINT prlist
Rule 26    stmt -> PROCEDURE begin LPAREN arglist RPAREN
Rule 27    stmt -> RETURN expr  [precedence=left, level=4]
Rule 28    stmt -> type ID
Rule 29    stmt -> expr
Rule 30    cond -> expr
Rule 31    begin -> <empty>
Rule 32    end -> <empty>
Rule 33    stmtlist -> stmtlist stmt
Rule 34    stmtlist -> stmtlist NEWLINE
Rule 35    stmtlist -> stmt
Rule 36    stmtlist -> NEWLINE
Rule 37    expr -> ID DEC  [precedence=left, level=7]
Rule 38    expr -> ID INC  [precedence=left, level=7]
Rule 39    expr -> DEC ID
Rule 40    expr -> INC ID
Rule 41    expr -> NOT expr  [precedence=left, level=7]
Rule 42    expr -> expr OR expr  [precedence=left, level=2]
Rule 43    expr -> expr AND expr  [precedence=left, level=3]
Rule 44    expr -> expr NE expr  [precedence=left, level=4]
Rule 45    expr -> expr EQ expr  [precedence=left, level=4]
Rule 46    expr -> expr LE expr  [precedence=left, level=4]
Rule 47    expr -> expr LT expr  [precedence=left, level=4]
Rule 48    expr -> expr GE expr  [precedence=left, level=4]
Rule 49    expr -> expr GT expr  [precedence=left, level=4]
Rule 50    expr -> MINUS expr  [precedence=left, level=5]
Rule 51    expr -> expr POWER expr  [precedence=right, level=8]
Rule 52    expr -> expr MODULE expr  [precedence=left, level=6]
Rule 53    expr -> expr DIVIDE expr  [precedence=left, level=6]
Rule 54    expr -> expr TIMES expr  [precedence=left, level=6]
Rule 55    expr -> expr MINUS expr  [precedence=left, level=5]
Rule 56    expr -> expr PLUS expr  [precedence=left, level=5]
Rule 57    expr -> LPAREN expr RPAREN
Rule 58    expr -> BLTIN LPAREN expr RPAREN
Rule 59    expr -> ID LPAREN prlist RPAREN
Rule 60    expr -> READ LPAREN ID RPAREN
Rule 61    expr -> FUNCTION begin LPAREN arglist RPAREN
Rule 62    expr -> assign
Rule 63    expr -> ARG
Rule 64    expr -> ID
Rule 65    expr -> FLOATT
Rule 66    expr -> INTEGER
Rule 67    prlist -> prlist COMMA STRINGG
Rule 68    prlist -> prlist COMMA expr
Rule 69    prlist -> STRINGG
Rule 70    prlist -> expr
Rule 71    formals -> ID COMMA formals
Rule 72    formals -> ID
Rule 73    formals -> empty
Rule 74    formalsss -> type ID COMMA formalsss
Rule 75    formalsss -> type ID
Rule 76    formalopt -> formalsss
Rule 77    formalopt -> formals
Rule 78    procname -> PROCEDURE
Rule 79    procname -> FUNCTION
Rule 80    procname -> ID
Rule 81    arglist -> arglist COMMA expr
Rule 82    arglist -> expr
Rule 83    arglist -> empty
Rule 84    empty -> <empty>

Terminals, with rules where they appear:

ADDEQ                : 16
AND                  : 43
ARG                  : 63
ASSIGN               : 17
BLTIN                : 58
COMMA                : 67 68 71 74 81
DEC                  : 37 39
DIVEQ                : 13
DIVIDE               : 53
ELSE                 : 21
EQ                   : 45
FLOAT                : 10
FLOATT               : 65
FOR                  : 23
FUNC                 : 19
FUNCTION             : 61 79
GE                   : 48
GT                   : 49
ID                   : 12 13 14 15 16 17 28 37 38 39 40 59 60 64 71 72 74 75 80
IF                   : 21 22
INC                  : 38 40
INT                  : 11
INTEGER              : 66
LBRACKET             : 20
LE                   : 46
LPAREN               : 18 19 21 22 23 24 26 57 58 59 60 61
LT                   : 47
MINUS                : 50 55
MODEQ                : 12
MODULE               : 52
MULEQ                : 14
NE                   : 44
NEWLINE              : 1 2 3 4 5 6 34 36
NOT                  : 41
OR                   : 42
PLUS                 : 56
POWER                : 51
PRINT                : 25
PROC                 : 18
PROCEDURE            : 26 78
RBRACKET             : 20
READ                 : 60
RETURN               : 27
RPAREN               : 18 19 21 22 23 24 26 57 58 59 60 61
SEMI                 : 23 23
STRING               : 9
STRINGG              : 67 69
SUBEQ                : 15
TIMES                : 54
VOID                 : 8
WHILE                : 24
error                : 1

Nonterminals, with rules where they appear:

arglist              : 26 61 81
assign               : 4 62
begin                : 26 61
cond                 : 21 22 23 23 23 24
defn                 : 5
empty                : 7 73 83
end                  : 21 21 22 23 24
expr                 : 2 12 13 14 15 16 17 27 29 30 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 51 51 52 52 53 53 54 54 55 55 56 56 57 58 68 70 81 82
formalopt            : 18 19
formals              : 71 77
formalsss            : 74 76
list                 : 1 2 3 4 5 6 0
prlist               : 25 59 67 68
procname             : 18 19
stmt                 : 3 18 19 21 21 22 23 24 33 35
stmtlist             : 20 33 34
type                 : 19 28 74 75


state 0

    (0) S' -> . list
    (1) list -> . list error NEWLINE
    (2) list -> . list expr NEWLINE
    (3) list -> . list stmt NEWLINE
    (4) list -> . list assign NEWLINE
    (5) list -> . list defn NEWLINE
    (6) list -> . list NEWLINE
    (7) list -> . empty
    (84) empty -> .
    error           reduce using rule 84 (empty -> .)
    NEWLINE         reduce using rule 84 (empty -> .)
    ID              reduce using rule 84 (empty -> .)
    DEC             reduce using rule 84 (empty -> .)
    INC             reduce using rule 84 (empty -> .)
    NOT             reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    LPAREN          reduce using rule 84 (empty -> .)
    BLTIN           reduce using rule 84 (empty -> .)
    READ            reduce using rule 84 (empty -> .)
    FUNCTION        reduce using rule 84 (empty -> .)
    ARG             reduce using rule 84 (empty -> .)
    FLOATT          reduce using rule 84 (empty -> .)
    INTEGER         reduce using rule 84 (empty -> .)
    LBRACKET        reduce using rule 84 (empty -> .)
    IF              reduce using rule 84 (empty -> .)
    FOR             reduce using rule 84 (empty -> .)
    WHILE           reduce using rule 84 (empty -> .)
    PRINT           reduce using rule 84 (empty -> .)
    PROCEDURE       reduce using rule 84 (empty -> .)
    RETURN          reduce using rule 84 (empty -> .)
    PROC            reduce using rule 84 (empty -> .)
    FUNC            reduce using rule 84 (empty -> .)
    VOID            reduce using rule 84 (empty -> .)
    STRING          reduce using rule 84 (empty -> .)
    FLOAT           reduce using rule 84 (empty -> .)
    INT             reduce using rule 84 (empty -> .)
    $end            reduce using rule 84 (empty -> .)

    list                           shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> list .
    (1) list -> list . error NEWLINE
    (2) list -> list . expr NEWLINE
    (3) list -> list . stmt NEWLINE
    (4) list -> list . assign NEWLINE
    (5) list -> list . defn NEWLINE
    (6) list -> list . NEWLINE
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (20) stmt -> . LBRACKET stmtlist RBRACKET
    (21) stmt -> . IF LPAREN cond RPAREN stmt end ELSE stmt end
    (22) stmt -> . IF LPAREN cond RPAREN stmt end
    (23) stmt -> . FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end
    (24) stmt -> . WHILE LPAREN cond RPAREN stmt end
    (25) stmt -> . PRINT prlist
    (26) stmt -> . PROCEDURE begin LPAREN arglist RPAREN
    (27) stmt -> . RETURN expr
    (28) stmt -> . type ID
    (29) stmt -> . expr
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    (18) defn -> . PROC procname LPAREN formalopt RPAREN stmt
    (19) defn -> . FUNC procname LPAREN formalopt RPAREN type stmt
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    error           shift and go to state 3
    NEWLINE         shift and go to state 4
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20
    LBRACKET        shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    WHILE           shift and go to state 24
    PRINT           shift and go to state 25
    PROCEDURE       shift and go to state 26
    RETURN          shift and go to state 27
    PROC            shift and go to state 29
    FUNC            shift and go to state 30
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34

    expr                           shift and go to state 5
    stmt                           shift and go to state 6
    assign                         shift and go to state 7
    defn                           shift and go to state 8
    type                           shift and go to state 28

state 2

    (7) list -> empty .
    error           reduce using rule 7 (list -> empty .)
    NEWLINE         reduce using rule 7 (list -> empty .)
    ID              reduce using rule 7 (list -> empty .)
    DEC             reduce using rule 7 (list -> empty .)
    INC             reduce using rule 7 (list -> empty .)
    NOT             reduce using rule 7 (list -> empty .)
    MINUS           reduce using rule 7 (list -> empty .)
    LPAREN          reduce using rule 7 (list -> empty .)
    BLTIN           reduce using rule 7 (list -> empty .)
    READ            reduce using rule 7 (list -> empty .)
    FUNCTION        reduce using rule 7 (list -> empty .)
    ARG             reduce using rule 7 (list -> empty .)
    FLOATT          reduce using rule 7 (list -> empty .)
    INTEGER         reduce using rule 7 (list -> empty .)
    LBRACKET        reduce using rule 7 (list -> empty .)
    IF              reduce using rule 7 (list -> empty .)
    FOR             reduce using rule 7 (list -> empty .)
    WHILE           reduce using rule 7 (list -> empty .)
    PRINT           reduce using rule 7 (list -> empty .)
    PROCEDURE       reduce using rule 7 (list -> empty .)
    RETURN          reduce using rule 7 (list -> empty .)
    PROC            reduce using rule 7 (list -> empty .)
    FUNC            reduce using rule 7 (list -> empty .)
    VOID            reduce using rule 7 (list -> empty .)
    STRING          reduce using rule 7 (list -> empty .)
    FLOAT           reduce using rule 7 (list -> empty .)
    INT             reduce using rule 7 (list -> empty .)
    $end            reduce using rule 7 (list -> empty .)


state 3

    (1) list -> list error . NEWLINE
    NEWLINE         shift and go to state 35


state 4

    (6) list -> list NEWLINE .
    error           reduce using rule 6 (list -> list NEWLINE .)
    NEWLINE         reduce using rule 6 (list -> list NEWLINE .)
    ID              reduce using rule 6 (list -> list NEWLINE .)
    DEC             reduce using rule 6 (list -> list NEWLINE .)
    INC             reduce using rule 6 (list -> list NEWLINE .)
    NOT             reduce using rule 6 (list -> list NEWLINE .)
    MINUS           reduce using rule 6 (list -> list NEWLINE .)
    LPAREN          reduce using rule 6 (list -> list NEWLINE .)
    BLTIN           reduce using rule 6 (list -> list NEWLINE .)
    READ            reduce using rule 6 (list -> list NEWLINE .)
    FUNCTION        reduce using rule 6 (list -> list NEWLINE .)
    ARG             reduce using rule 6 (list -> list NEWLINE .)
    FLOATT          reduce using rule 6 (list -> list NEWLINE .)
    INTEGER         reduce using rule 6 (list -> list NEWLINE .)
    LBRACKET        reduce using rule 6 (list -> list NEWLINE .)
    IF              reduce using rule 6 (list -> list NEWLINE .)
    FOR             reduce using rule 6 (list -> list NEWLINE .)
    WHILE           reduce using rule 6 (list -> list NEWLINE .)
    PRINT           reduce using rule 6 (list -> list NEWLINE .)
    PROCEDURE       reduce using rule 6 (list -> list NEWLINE .)
    RETURN          reduce using rule 6 (list -> list NEWLINE .)
    PROC            reduce using rule 6 (list -> list NEWLINE .)
    FUNC            reduce using rule 6 (list -> list NEWLINE .)
    VOID            reduce using rule 6 (list -> list NEWLINE .)
    STRING          reduce using rule 6 (list -> list NEWLINE .)
    FLOAT           reduce using rule 6 (list -> list NEWLINE .)
    INT             reduce using rule 6 (list -> list NEWLINE .)
    $end            reduce using rule 6 (list -> list NEWLINE .)


state 5

    (2) list -> list expr . NEWLINE
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    (29) stmt -> expr .
  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 36
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 6

    (3) list -> list stmt . NEWLINE
    NEWLINE         shift and go to state 51


state 7

    (4) list -> list assign . NEWLINE
    (62) expr -> assign .
  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 52
    OR              reduce using rule 62 (expr -> assign .)
    AND             reduce using rule 62 (expr -> assign .)
    NE              reduce using rule 62 (expr -> assign .)
    EQ              reduce using rule 62 (expr -> assign .)
    LE              reduce using rule 62 (expr -> assign .)
    LT              reduce using rule 62 (expr -> assign .)
    GE              reduce using rule 62 (expr -> assign .)
    GT              reduce using rule 62 (expr -> assign .)
    POWER           reduce using rule 62 (expr -> assign .)
    MODULE          reduce using rule 62 (expr -> assign .)
    DIVIDE          reduce using rule 62 (expr -> assign .)
    TIMES           reduce using rule 62 (expr -> assign .)
    MINUS           reduce using rule 62 (expr -> assign .)
    PLUS            reduce using rule 62 (expr -> assign .)


state 8

    (5) list -> list defn . NEWLINE
    NEWLINE         shift and go to state 53


state 9

    (37) expr -> ID . DEC
    (38) expr -> ID . INC
    (59) expr -> ID . LPAREN prlist RPAREN
    (64) expr -> ID .
    (12) assign -> ID . MODEQ expr
    (13) assign -> ID . DIVEQ expr
    (14) assign -> ID . MULEQ expr
    (15) assign -> ID . SUBEQ expr
    (16) assign -> ID . ADDEQ expr
    (17) assign -> ID . ASSIGN expr
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    DEC             shift and go to state 54
    INC             shift and go to state 55
    LPAREN          shift and go to state 56
    NEWLINE         reduce using rule 64 (expr -> ID .)
    OR              reduce using rule 64 (expr -> ID .)
    AND             reduce using rule 64 (expr -> ID .)
    NE              reduce using rule 64 (expr -> ID .)
    EQ              reduce using rule 64 (expr -> ID .)
    LE              reduce using rule 64 (expr -> ID .)
    LT              reduce using rule 64 (expr -> ID .)
    GE              reduce using rule 64 (expr -> ID .)
    GT              reduce using rule 64 (expr -> ID .)
    POWER           reduce using rule 64 (expr -> ID .)
    MODULE          reduce using rule 64 (expr -> ID .)
    DIVIDE          reduce using rule 64 (expr -> ID .)
    TIMES           reduce using rule 64 (expr -> ID .)
    MINUS           reduce using rule 64 (expr -> ID .)
    PLUS            reduce using rule 64 (expr -> ID .)
    RPAREN          reduce using rule 64 (expr -> ID .)
    RBRACKET        reduce using rule 64 (expr -> ID .)
    LBRACKET        reduce using rule 64 (expr -> ID .)
    IF              reduce using rule 64 (expr -> ID .)
    FOR             reduce using rule 64 (expr -> ID .)
    WHILE           reduce using rule 64 (expr -> ID .)
    PRINT           reduce using rule 64 (expr -> ID .)
    PROCEDURE       reduce using rule 64 (expr -> ID .)
    RETURN          reduce using rule 64 (expr -> ID .)
    VOID            reduce using rule 64 (expr -> ID .)
    STRING          reduce using rule 64 (expr -> ID .)
    FLOAT           reduce using rule 64 (expr -> ID .)
    INT             reduce using rule 64 (expr -> ID .)
    ID              reduce using rule 64 (expr -> ID .)
    NOT             reduce using rule 64 (expr -> ID .)
    BLTIN           reduce using rule 64 (expr -> ID .)
    READ            reduce using rule 64 (expr -> ID .)
    FUNCTION        reduce using rule 64 (expr -> ID .)
    ARG             reduce using rule 64 (expr -> ID .)
    FLOATT          reduce using rule 64 (expr -> ID .)
    INTEGER         reduce using rule 64 (expr -> ID .)
    COMMA           reduce using rule 64 (expr -> ID .)
    ELSE            reduce using rule 64 (expr -> ID .)
    SEMI            reduce using rule 64 (expr -> ID .)
    MODEQ           shift and go to state 57
    DIVEQ           shift and go to state 58
    MULEQ           shift and go to state 59
    SUBEQ           shift and go to state 60
    ADDEQ           shift and go to state 61
    ASSIGN          shift and go to state 62


state 10

    (39) expr -> DEC . ID
    ID              shift and go to state 63


state 11

    (40) expr -> INC . ID
    ID              shift and go to state 64


state 12

    (41) expr -> NOT . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 65
    assign                         shift and go to state 66

state 13

    (50) expr -> MINUS . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 67
    assign                         shift and go to state 66

state 14

    (57) expr -> LPAREN . expr RPAREN
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 68
    assign                         shift and go to state 66

state 15

    (58) expr -> BLTIN . LPAREN expr RPAREN
    LPAREN          shift and go to state 69


state 16

    (60) expr -> READ . LPAREN ID RPAREN
    LPAREN          shift and go to state 70


state 17

    (61) expr -> FUNCTION . begin LPAREN arglist RPAREN
    (31) begin -> .
    LPAREN          reduce using rule 31 (begin -> .)

    begin                          shift and go to state 71

state 18

    (63) expr -> ARG .
    NEWLINE         reduce using rule 63 (expr -> ARG .)
    OR              reduce using rule 63 (expr -> ARG .)
    AND             reduce using rule 63 (expr -> ARG .)
    NE              reduce using rule 63 (expr -> ARG .)
    EQ              reduce using rule 63 (expr -> ARG .)
    LE              reduce using rule 63 (expr -> ARG .)
    LT              reduce using rule 63 (expr -> ARG .)
    GE              reduce using rule 63 (expr -> ARG .)
    GT              reduce using rule 63 (expr -> ARG .)
    POWER           reduce using rule 63 (expr -> ARG .)
    MODULE          reduce using rule 63 (expr -> ARG .)
    DIVIDE          reduce using rule 63 (expr -> ARG .)
    TIMES           reduce using rule 63 (expr -> ARG .)
    MINUS           reduce using rule 63 (expr -> ARG .)
    PLUS            reduce using rule 63 (expr -> ARG .)
    RPAREN          reduce using rule 63 (expr -> ARG .)
    RBRACKET        reduce using rule 63 (expr -> ARG .)
    LBRACKET        reduce using rule 63 (expr -> ARG .)
    IF              reduce using rule 63 (expr -> ARG .)
    FOR             reduce using rule 63 (expr -> ARG .)
    WHILE           reduce using rule 63 (expr -> ARG .)
    PRINT           reduce using rule 63 (expr -> ARG .)
    PROCEDURE       reduce using rule 63 (expr -> ARG .)
    RETURN          reduce using rule 63 (expr -> ARG .)
    VOID            reduce using rule 63 (expr -> ARG .)
    STRING          reduce using rule 63 (expr -> ARG .)
    FLOAT           reduce using rule 63 (expr -> ARG .)
    INT             reduce using rule 63 (expr -> ARG .)
    ID              reduce using rule 63 (expr -> ARG .)
    DEC             reduce using rule 63 (expr -> ARG .)
    INC             reduce using rule 63 (expr -> ARG .)
    NOT             reduce using rule 63 (expr -> ARG .)
    LPAREN          reduce using rule 63 (expr -> ARG .)
    BLTIN           reduce using rule 63 (expr -> ARG .)
    READ            reduce using rule 63 (expr -> ARG .)
    FUNCTION        reduce using rule 63 (expr -> ARG .)
    ARG             reduce using rule 63 (expr -> ARG .)
    FLOATT          reduce using rule 63 (expr -> ARG .)
    INTEGER         reduce using rule 63 (expr -> ARG .)
    COMMA           reduce using rule 63 (expr -> ARG .)
    ELSE            reduce using rule 63 (expr -> ARG .)
    SEMI            reduce using rule 63 (expr -> ARG .)


state 19

    (65) expr -> FLOATT .
    NEWLINE         reduce using rule 65 (expr -> FLOATT .)
    OR              reduce using rule 65 (expr -> FLOATT .)
    AND             reduce using rule 65 (expr -> FLOATT .)
    NE              reduce using rule 65 (expr -> FLOATT .)
    EQ              reduce using rule 65 (expr -> FLOATT .)
    LE              reduce using rule 65 (expr -> FLOATT .)
    LT              reduce using rule 65 (expr -> FLOATT .)
    GE              reduce using rule 65 (expr -> FLOATT .)
    GT              reduce using rule 65 (expr -> FLOATT .)
    POWER           reduce using rule 65 (expr -> FLOATT .)
    MODULE          reduce using rule 65 (expr -> FLOATT .)
    DIVIDE          reduce using rule 65 (expr -> FLOATT .)
    TIMES           reduce using rule 65 (expr -> FLOATT .)
    MINUS           reduce using rule 65 (expr -> FLOATT .)
    PLUS            reduce using rule 65 (expr -> FLOATT .)
    RPAREN          reduce using rule 65 (expr -> FLOATT .)
    RBRACKET        reduce using rule 65 (expr -> FLOATT .)
    LBRACKET        reduce using rule 65 (expr -> FLOATT .)
    IF              reduce using rule 65 (expr -> FLOATT .)
    FOR             reduce using rule 65 (expr -> FLOATT .)
    WHILE           reduce using rule 65 (expr -> FLOATT .)
    PRINT           reduce using rule 65 (expr -> FLOATT .)
    PROCEDURE       reduce using rule 65 (expr -> FLOATT .)
    RETURN          reduce using rule 65 (expr -> FLOATT .)
    VOID            reduce using rule 65 (expr -> FLOATT .)
    STRING          reduce using rule 65 (expr -> FLOATT .)
    FLOAT           reduce using rule 65 (expr -> FLOATT .)
    INT             reduce using rule 65 (expr -> FLOATT .)
    ID              reduce using rule 65 (expr -> FLOATT .)
    DEC             reduce using rule 65 (expr -> FLOATT .)
    INC             reduce using rule 65 (expr -> FLOATT .)
    NOT             reduce using rule 65 (expr -> FLOATT .)
    LPAREN          reduce using rule 65 (expr -> FLOATT .)
    BLTIN           reduce using rule 65 (expr -> FLOATT .)
    READ            reduce using rule 65 (expr -> FLOATT .)
    FUNCTION        reduce using rule 65 (expr -> FLOATT .)
    ARG             reduce using rule 65 (expr -> FLOATT .)
    FLOATT          reduce using rule 65 (expr -> FLOATT .)
    INTEGER         reduce using rule 65 (expr -> FLOATT .)
    COMMA           reduce using rule 65 (expr -> FLOATT .)
    ELSE            reduce using rule 65 (expr -> FLOATT .)
    SEMI            reduce using rule 65 (expr -> FLOATT .)


state 20

    (66) expr -> INTEGER .
    NEWLINE         reduce using rule 66 (expr -> INTEGER .)
    OR              reduce using rule 66 (expr -> INTEGER .)
    AND             reduce using rule 66 (expr -> INTEGER .)
    NE              reduce using rule 66 (expr -> INTEGER .)
    EQ              reduce using rule 66 (expr -> INTEGER .)
    LE              reduce using rule 66 (expr -> INTEGER .)
    LT              reduce using rule 66 (expr -> INTEGER .)
    GE              reduce using rule 66 (expr -> INTEGER .)
    GT              reduce using rule 66 (expr -> INTEGER .)
    POWER           reduce using rule 66 (expr -> INTEGER .)
    MODULE          reduce using rule 66 (expr -> INTEGER .)
    DIVIDE          reduce using rule 66 (expr -> INTEGER .)
    TIMES           reduce using rule 66 (expr -> INTEGER .)
    MINUS           reduce using rule 66 (expr -> INTEGER .)
    PLUS            reduce using rule 66 (expr -> INTEGER .)
    RPAREN          reduce using rule 66 (expr -> INTEGER .)
    RBRACKET        reduce using rule 66 (expr -> INTEGER .)
    LBRACKET        reduce using rule 66 (expr -> INTEGER .)
    IF              reduce using rule 66 (expr -> INTEGER .)
    FOR             reduce using rule 66 (expr -> INTEGER .)
    WHILE           reduce using rule 66 (expr -> INTEGER .)
    PRINT           reduce using rule 66 (expr -> INTEGER .)
    PROCEDURE       reduce using rule 66 (expr -> INTEGER .)
    RETURN          reduce using rule 66 (expr -> INTEGER .)
    VOID            reduce using rule 66 (expr -> INTEGER .)
    STRING          reduce using rule 66 (expr -> INTEGER .)
    FLOAT           reduce using rule 66 (expr -> INTEGER .)
    INT             reduce using rule 66 (expr -> INTEGER .)
    ID              reduce using rule 66 (expr -> INTEGER .)
    DEC             reduce using rule 66 (expr -> INTEGER .)
    INC             reduce using rule 66 (expr -> INTEGER .)
    NOT             reduce using rule 66 (expr -> INTEGER .)
    LPAREN          reduce using rule 66 (expr -> INTEGER .)
    BLTIN           reduce using rule 66 (expr -> INTEGER .)
    READ            reduce using rule 66 (expr -> INTEGER .)
    FUNCTION        reduce using rule 66 (expr -> INTEGER .)
    ARG             reduce using rule 66 (expr -> INTEGER .)
    FLOATT          reduce using rule 66 (expr -> INTEGER .)
    INTEGER         reduce using rule 66 (expr -> INTEGER .)
    COMMA           reduce using rule 66 (expr -> INTEGER .)
    ELSE            reduce using rule 66 (expr -> INTEGER .)
    SEMI            reduce using rule 66 (expr -> INTEGER .)


state 21

    (20) stmt -> LBRACKET . stmtlist RBRACKET
    (33) stmtlist -> . stmtlist stmt
    (34) stmtlist -> . stmtlist NEWLINE
    (35) stmtlist -> . stmt
    (36) stmtlist -> . NEWLINE
    (20) stmt -> . LBRACKET stmtlist RBRACKET
    (21) stmt -> . IF LPAREN cond RPAREN stmt end ELSE stmt end
    (22) stmt -> . IF LPAREN cond RPAREN stmt end
    (23) stmt -> . FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end
    (24) stmt -> . WHILE LPAREN cond RPAREN stmt end
    (25) stmt -> . PRINT prlist
    (26) stmt -> . PROCEDURE begin LPAREN arglist RPAREN
    (27) stmt -> . RETURN expr
    (28) stmt -> . type ID
    (29) stmt -> . expr
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    NEWLINE         shift and go to state 74
    LBRACKET        shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    WHILE           shift and go to state 24
    PRINT           shift and go to state 25
    PROCEDURE       shift and go to state 26
    RETURN          shift and go to state 27
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    stmtlist                       shift and go to state 72
    stmt                           shift and go to state 73
    expr                           shift and go to state 75
    type                           shift and go to state 28
    assign                         shift and go to state 66

state 22

    (21) stmt -> IF . LPAREN cond RPAREN stmt end ELSE stmt end
    (22) stmt -> IF . LPAREN cond RPAREN stmt end
    LPAREN          shift and go to state 76


state 23

    (23) stmt -> FOR . LPAREN cond SEMI cond SEMI cond RPAREN stmt end
    LPAREN          shift and go to state 77


state 24

    (24) stmt -> WHILE . LPAREN cond RPAREN stmt end
    LPAREN          shift and go to state 78


state 25

    (25) stmt -> PRINT . prlist
    (67) prlist -> . prlist COMMA STRINGG
    (68) prlist -> . prlist COMMA expr
    (69) prlist -> . STRINGG
    (70) prlist -> . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    STRINGG         shift and go to state 80
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    prlist                         shift and go to state 79
    expr                           shift and go to state 81
    assign                         shift and go to state 66

state 26

    (26) stmt -> PROCEDURE . begin LPAREN arglist RPAREN
    (31) begin -> .
    LPAREN          reduce using rule 31 (begin -> .)

    begin                          shift and go to state 82

state 27

    (27) stmt -> RETURN . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 83
    assign                         shift and go to state 66

state 28

    (28) stmt -> type . ID
    ID              shift and go to state 84


state 29

    (18) defn -> PROC . procname LPAREN formalopt RPAREN stmt
    (78) procname -> . PROCEDURE
    (79) procname -> . FUNCTION
    (80) procname -> . ID
    PROCEDURE       shift and go to state 86
    FUNCTION        shift and go to state 87
    ID              shift and go to state 88

    procname                       shift and go to state 85

state 30

    (19) defn -> FUNC . procname LPAREN formalopt RPAREN type stmt
    (78) procname -> . PROCEDURE
    (79) procname -> . FUNCTION
    (80) procname -> . ID
    PROCEDURE       shift and go to state 86
    FUNCTION        shift and go to state 87
    ID              shift and go to state 88

    procname                       shift and go to state 89

state 31

    (8) type -> VOID .
    ID              reduce using rule 8 (type -> VOID .)
    LBRACKET        reduce using rule 8 (type -> VOID .)
    IF              reduce using rule 8 (type -> VOID .)
    FOR             reduce using rule 8 (type -> VOID .)
    WHILE           reduce using rule 8 (type -> VOID .)
    PRINT           reduce using rule 8 (type -> VOID .)
    PROCEDURE       reduce using rule 8 (type -> VOID .)
    RETURN          reduce using rule 8 (type -> VOID .)
    VOID            reduce using rule 8 (type -> VOID .)
    STRING          reduce using rule 8 (type -> VOID .)
    FLOAT           reduce using rule 8 (type -> VOID .)
    INT             reduce using rule 8 (type -> VOID .)
    DEC             reduce using rule 8 (type -> VOID .)
    INC             reduce using rule 8 (type -> VOID .)
    NOT             reduce using rule 8 (type -> VOID .)
    MINUS           reduce using rule 8 (type -> VOID .)
    LPAREN          reduce using rule 8 (type -> VOID .)
    BLTIN           reduce using rule 8 (type -> VOID .)
    READ            reduce using rule 8 (type -> VOID .)
    FUNCTION        reduce using rule 8 (type -> VOID .)
    ARG             reduce using rule 8 (type -> VOID .)
    FLOATT          reduce using rule 8 (type -> VOID .)
    INTEGER         reduce using rule 8 (type -> VOID .)


state 32

    (9) type -> STRING .
    ID              reduce using rule 9 (type -> STRING .)
    LBRACKET        reduce using rule 9 (type -> STRING .)
    IF              reduce using rule 9 (type -> STRING .)
    FOR             reduce using rule 9 (type -> STRING .)
    WHILE           reduce using rule 9 (type -> STRING .)
    PRINT           reduce using rule 9 (type -> STRING .)
    PROCEDURE       reduce using rule 9 (type -> STRING .)
    RETURN          reduce using rule 9 (type -> STRING .)
    VOID            reduce using rule 9 (type -> STRING .)
    STRING          reduce using rule 9 (type -> STRING .)
    FLOAT           reduce using rule 9 (type -> STRING .)
    INT             reduce using rule 9 (type -> STRING .)
    DEC             reduce using rule 9 (type -> STRING .)
    INC             reduce using rule 9 (type -> STRING .)
    NOT             reduce using rule 9 (type -> STRING .)
    MINUS           reduce using rule 9 (type -> STRING .)
    LPAREN          reduce using rule 9 (type -> STRING .)
    BLTIN           reduce using rule 9 (type -> STRING .)
    READ            reduce using rule 9 (type -> STRING .)
    FUNCTION        reduce using rule 9 (type -> STRING .)
    ARG             reduce using rule 9 (type -> STRING .)
    FLOATT          reduce using rule 9 (type -> STRING .)
    INTEGER         reduce using rule 9 (type -> STRING .)


state 33

    (10) type -> FLOAT .
    ID              reduce using rule 10 (type -> FLOAT .)
    LBRACKET        reduce using rule 10 (type -> FLOAT .)
    IF              reduce using rule 10 (type -> FLOAT .)
    FOR             reduce using rule 10 (type -> FLOAT .)
    WHILE           reduce using rule 10 (type -> FLOAT .)
    PRINT           reduce using rule 10 (type -> FLOAT .)
    PROCEDURE       reduce using rule 10 (type -> FLOAT .)
    RETURN          reduce using rule 10 (type -> FLOAT .)
    VOID            reduce using rule 10 (type -> FLOAT .)
    STRING          reduce using rule 10 (type -> FLOAT .)
    FLOAT           reduce using rule 10 (type -> FLOAT .)
    INT             reduce using rule 10 (type -> FLOAT .)
    DEC             reduce using rule 10 (type -> FLOAT .)
    INC             reduce using rule 10 (type -> FLOAT .)
    NOT             reduce using rule 10 (type -> FLOAT .)
    MINUS           reduce using rule 10 (type -> FLOAT .)
    LPAREN          reduce using rule 10 (type -> FLOAT .)
    BLTIN           reduce using rule 10 (type -> FLOAT .)
    READ            reduce using rule 10 (type -> FLOAT .)
    FUNCTION        reduce using rule 10 (type -> FLOAT .)
    ARG             reduce using rule 10 (type -> FLOAT .)
    FLOATT          reduce using rule 10 (type -> FLOAT .)
    INTEGER         reduce using rule 10 (type -> FLOAT .)


state 34

    (11) type -> INT .
    ID              reduce using rule 11 (type -> INT .)
    LBRACKET        reduce using rule 11 (type -> INT .)
    IF              reduce using rule 11 (type -> INT .)
    FOR             reduce using rule 11 (type -> INT .)
    WHILE           reduce using rule 11 (type -> INT .)
    PRINT           reduce using rule 11 (type -> INT .)
    PROCEDURE       reduce using rule 11 (type -> INT .)
    RETURN          reduce using rule 11 (type -> INT .)
    VOID            reduce using rule 11 (type -> INT .)
    STRING          reduce using rule 11 (type -> INT .)
    FLOAT           reduce using rule 11 (type -> INT .)
    INT             reduce using rule 11 (type -> INT .)
    DEC             reduce using rule 11 (type -> INT .)
    INC             reduce using rule 11 (type -> INT .)
    NOT             reduce using rule 11 (type -> INT .)
    MINUS           reduce using rule 11 (type -> INT .)
    LPAREN          reduce using rule 11 (type -> INT .)
    BLTIN           reduce using rule 11 (type -> INT .)
    READ            reduce using rule 11 (type -> INT .)
    FUNCTION        reduce using rule 11 (type -> INT .)
    ARG             reduce using rule 11 (type -> INT .)
    FLOATT          reduce using rule 11 (type -> INT .)
    INTEGER         reduce using rule 11 (type -> INT .)


state 35

    (1) list -> list error NEWLINE .
    error           reduce using rule 1 (list -> list error NEWLINE .)
    NEWLINE         reduce using rule 1 (list -> list error NEWLINE .)
    ID              reduce using rule 1 (list -> list error NEWLINE .)
    DEC             reduce using rule 1 (list -> list error NEWLINE .)
    INC             reduce using rule 1 (list -> list error NEWLINE .)
    NOT             reduce using rule 1 (list -> list error NEWLINE .)
    MINUS           reduce using rule 1 (list -> list error NEWLINE .)
    LPAREN          reduce using rule 1 (list -> list error NEWLINE .)
    BLTIN           reduce using rule 1 (list -> list error NEWLINE .)
    READ            reduce using rule 1 (list -> list error NEWLINE .)
    FUNCTION        reduce using rule 1 (list -> list error NEWLINE .)
    ARG             reduce using rule 1 (list -> list error NEWLINE .)
    FLOATT          reduce using rule 1 (list -> list error NEWLINE .)
    INTEGER         reduce using rule 1 (list -> list error NEWLINE .)
    LBRACKET        reduce using rule 1 (list -> list error NEWLINE .)
    IF              reduce using rule 1 (list -> list error NEWLINE .)
    FOR             reduce using rule 1 (list -> list error NEWLINE .)
    WHILE           reduce using rule 1 (list -> list error NEWLINE .)
    PRINT           reduce using rule 1 (list -> list error NEWLINE .)
    PROCEDURE       reduce using rule 1 (list -> list error NEWLINE .)
    RETURN          reduce using rule 1 (list -> list error NEWLINE .)
    PROC            reduce using rule 1 (list -> list error NEWLINE .)
    FUNC            reduce using rule 1 (list -> list error NEWLINE .)
    VOID            reduce using rule 1 (list -> list error NEWLINE .)
    STRING          reduce using rule 1 (list -> list error NEWLINE .)
    FLOAT           reduce using rule 1 (list -> list error NEWLINE .)
    INT             reduce using rule 1 (list -> list error NEWLINE .)
    $end            reduce using rule 1 (list -> list error NEWLINE .)


state 36

    (2) list -> list expr NEWLINE .
    error           reduce using rule 2 (list -> list expr NEWLINE .)
    NEWLINE         reduce using rule 2 (list -> list expr NEWLINE .)
    ID              reduce using rule 2 (list -> list expr NEWLINE .)
    DEC             reduce using rule 2 (list -> list expr NEWLINE .)
    INC             reduce using rule 2 (list -> list expr NEWLINE .)
    NOT             reduce using rule 2 (list -> list expr NEWLINE .)
    MINUS           reduce using rule 2 (list -> list expr NEWLINE .)
    LPAREN          reduce using rule 2 (list -> list expr NEWLINE .)
    BLTIN           reduce using rule 2 (list -> list expr NEWLINE .)
    READ            reduce using rule 2 (list -> list expr NEWLINE .)
    FUNCTION        reduce using rule 2 (list -> list expr NEWLINE .)
    ARG             reduce using rule 2 (list -> list expr NEWLINE .)
    FLOATT          reduce using rule 2 (list -> list expr NEWLINE .)
    INTEGER         reduce using rule 2 (list -> list expr NEWLINE .)
    LBRACKET        reduce using rule 2 (list -> list expr NEWLINE .)
    IF              reduce using rule 2 (list -> list expr NEWLINE .)
    FOR             reduce using rule 2 (list -> list expr NEWLINE .)
    WHILE           reduce using rule 2 (list -> list expr NEWLINE .)
    PRINT           reduce using rule 2 (list -> list expr NEWLINE .)
    PROCEDURE       reduce using rule 2 (list -> list expr NEWLINE .)
    RETURN          reduce using rule 2 (list -> list expr NEWLINE .)
    PROC            reduce using rule 2 (list -> list expr NEWLINE .)
    FUNC            reduce using rule 2 (list -> list expr NEWLINE .)
    VOID            reduce using rule 2 (list -> list expr NEWLINE .)
    STRING          reduce using rule 2 (list -> list expr NEWLINE .)
    FLOAT           reduce using rule 2 (list -> list expr NEWLINE .)
    INT             reduce using rule 2 (list -> list expr NEWLINE .)
    $end            reduce using rule 2 (list -> list expr NEWLINE .)


state 37

    (42) expr -> expr OR . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 90
    assign                         shift and go to state 66

state 38

    (43) expr -> expr AND . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 91
    assign                         shift and go to state 66

state 39

    (44) expr -> expr NE . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 92
    assign                         shift and go to state 66

state 40

    (45) expr -> expr EQ . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 93
    assign                         shift and go to state 66

state 41

    (46) expr -> expr LE . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 94
    assign                         shift and go to state 66

state 42

    (47) expr -> expr LT . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 95
    assign                         shift and go to state 66

state 43

    (48) expr -> expr GE . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 96
    assign                         shift and go to state 66

state 44

    (49) expr -> expr GT . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 97
    assign                         shift and go to state 66

state 45

    (51) expr -> expr POWER . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 98
    assign                         shift and go to state 66

state 46

    (52) expr -> expr MODULE . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 99
    assign                         shift and go to state 66

state 47

    (53) expr -> expr DIVIDE . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 100
    assign                         shift and go to state 66

state 48

    (54) expr -> expr TIMES . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 101
    assign                         shift and go to state 66

state 49

    (55) expr -> expr MINUS . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 102
    assign                         shift and go to state 66

state 50

    (56) expr -> expr PLUS . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 103
    assign                         shift and go to state 66

state 51

    (3) list -> list stmt NEWLINE .
    error           reduce using rule 3 (list -> list stmt NEWLINE .)
    NEWLINE         reduce using rule 3 (list -> list stmt NEWLINE .)
    ID              reduce using rule 3 (list -> list stmt NEWLINE .)
    DEC             reduce using rule 3 (list -> list stmt NEWLINE .)
    INC             reduce using rule 3 (list -> list stmt NEWLINE .)
    NOT             reduce using rule 3 (list -> list stmt NEWLINE .)
    MINUS           reduce using rule 3 (list -> list stmt NEWLINE .)
    LPAREN          reduce using rule 3 (list -> list stmt NEWLINE .)
    BLTIN           reduce using rule 3 (list -> list stmt NEWLINE .)
    READ            reduce using rule 3 (list -> list stmt NEWLINE .)
    FUNCTION        reduce using rule 3 (list -> list stmt NEWLINE .)
    ARG             reduce using rule 3 (list -> list stmt NEWLINE .)
    FLOATT          reduce using rule 3 (list -> list stmt NEWLINE .)
    INTEGER         reduce using rule 3 (list -> list stmt NEWLINE .)
    LBRACKET        reduce using rule 3 (list -> list stmt NEWLINE .)
    IF              reduce using rule 3 (list -> list stmt NEWLINE .)
    FOR             reduce using rule 3 (list -> list stmt NEWLINE .)
    WHILE           reduce using rule 3 (list -> list stmt NEWLINE .)
    PRINT           reduce using rule 3 (list -> list stmt NEWLINE .)
    PROCEDURE       reduce using rule 3 (list -> list stmt NEWLINE .)
    RETURN          reduce using rule 3 (list -> list stmt NEWLINE .)
    PROC            reduce using rule 3 (list -> list stmt NEWLINE .)
    FUNC            reduce using rule 3 (list -> list stmt NEWLINE .)
    VOID            reduce using rule 3 (list -> list stmt NEWLINE .)
    STRING          reduce using rule 3 (list -> list stmt NEWLINE .)
    FLOAT           reduce using rule 3 (list -> list stmt NEWLINE .)
    INT             reduce using rule 3 (list -> list stmt NEWLINE .)
    $end            reduce using rule 3 (list -> list stmt NEWLINE .)


state 52

    (4) list -> list assign NEWLINE .
    error           reduce using rule 4 (list -> list assign NEWLINE .)
    NEWLINE         reduce using rule 4 (list -> list assign NEWLINE .)
    ID              reduce using rule 4 (list -> list assign NEWLINE .)
    DEC             reduce using rule 4 (list -> list assign NEWLINE .)
    INC             reduce using rule 4 (list -> list assign NEWLINE .)
    NOT             reduce using rule 4 (list -> list assign NEWLINE .)
    MINUS           reduce using rule 4 (list -> list assign NEWLINE .)
    LPAREN          reduce using rule 4 (list -> list assign NEWLINE .)
    BLTIN           reduce using rule 4 (list -> list assign NEWLINE .)
    READ            reduce using rule 4 (list -> list assign NEWLINE .)
    FUNCTION        reduce using rule 4 (list -> list assign NEWLINE .)
    ARG             reduce using rule 4 (list -> list assign NEWLINE .)
    FLOATT          reduce using rule 4 (list -> list assign NEWLINE .)
    INTEGER         reduce using rule 4 (list -> list assign NEWLINE .)
    LBRACKET        reduce using rule 4 (list -> list assign NEWLINE .)
    IF              reduce using rule 4 (list -> list assign NEWLINE .)
    FOR             reduce using rule 4 (list -> list assign NEWLINE .)
    WHILE           reduce using rule 4 (list -> list assign NEWLINE .)
    PRINT           reduce using rule 4 (list -> list assign NEWLINE .)
    PROCEDURE       reduce using rule 4 (list -> list assign NEWLINE .)
    RETURN          reduce using rule 4 (list -> list assign NEWLINE .)
    PROC            reduce using rule 4 (list -> list assign NEWLINE .)
    FUNC            reduce using rule 4 (list -> list assign NEWLINE .)
    VOID            reduce using rule 4 (list -> list assign NEWLINE .)
    STRING          reduce using rule 4 (list -> list assign NEWLINE .)
    FLOAT           reduce using rule 4 (list -> list assign NEWLINE .)
    INT             reduce using rule 4 (list -> list assign NEWLINE .)
    $end            reduce using rule 4 (list -> list assign NEWLINE .)


state 53

    (5) list -> list defn NEWLINE .
    error           reduce using rule 5 (list -> list defn NEWLINE .)
    NEWLINE         reduce using rule 5 (list -> list defn NEWLINE .)
    ID              reduce using rule 5 (list -> list defn NEWLINE .)
    DEC             reduce using rule 5 (list -> list defn NEWLINE .)
    INC             reduce using rule 5 (list -> list defn NEWLINE .)
    NOT             reduce using rule 5 (list -> list defn NEWLINE .)
    MINUS           reduce using rule 5 (list -> list defn NEWLINE .)
    LPAREN          reduce using rule 5 (list -> list defn NEWLINE .)
    BLTIN           reduce using rule 5 (list -> list defn NEWLINE .)
    READ            reduce using rule 5 (list -> list defn NEWLINE .)
    FUNCTION        reduce using rule 5 (list -> list defn NEWLINE .)
    ARG             reduce using rule 5 (list -> list defn NEWLINE .)
    FLOATT          reduce using rule 5 (list -> list defn NEWLINE .)
    INTEGER         reduce using rule 5 (list -> list defn NEWLINE .)
    LBRACKET        reduce using rule 5 (list -> list defn NEWLINE .)
    IF              reduce using rule 5 (list -> list defn NEWLINE .)
    FOR             reduce using rule 5 (list -> list defn NEWLINE .)
    WHILE           reduce using rule 5 (list -> list defn NEWLINE .)
    PRINT           reduce using rule 5 (list -> list defn NEWLINE .)
    PROCEDURE       reduce using rule 5 (list -> list defn NEWLINE .)
    RETURN          reduce using rule 5 (list -> list defn NEWLINE .)
    PROC            reduce using rule 5 (list -> list defn NEWLINE .)
    FUNC            reduce using rule 5 (list -> list defn NEWLINE .)
    VOID            reduce using rule 5 (list -> list defn NEWLINE .)
    STRING          reduce using rule 5 (list -> list defn NEWLINE .)
    FLOAT           reduce using rule 5 (list -> list defn NEWLINE .)
    INT             reduce using rule 5 (list -> list defn NEWLINE .)
    $end            reduce using rule 5 (list -> list defn NEWLINE .)


state 54

    (37) expr -> ID DEC .
    NEWLINE         reduce using rule 37 (expr -> ID DEC .)
    OR              reduce using rule 37 (expr -> ID DEC .)
    AND             reduce using rule 37 (expr -> ID DEC .)
    NE              reduce using rule 37 (expr -> ID DEC .)
    EQ              reduce using rule 37 (expr -> ID DEC .)
    LE              reduce using rule 37 (expr -> ID DEC .)
    LT              reduce using rule 37 (expr -> ID DEC .)
    GE              reduce using rule 37 (expr -> ID DEC .)
    GT              reduce using rule 37 (expr -> ID DEC .)
    POWER           reduce using rule 37 (expr -> ID DEC .)
    MODULE          reduce using rule 37 (expr -> ID DEC .)
    DIVIDE          reduce using rule 37 (expr -> ID DEC .)
    TIMES           reduce using rule 37 (expr -> ID DEC .)
    MINUS           reduce using rule 37 (expr -> ID DEC .)
    PLUS            reduce using rule 37 (expr -> ID DEC .)
    RPAREN          reduce using rule 37 (expr -> ID DEC .)
    RBRACKET        reduce using rule 37 (expr -> ID DEC .)
    LBRACKET        reduce using rule 37 (expr -> ID DEC .)
    IF              reduce using rule 37 (expr -> ID DEC .)
    FOR             reduce using rule 37 (expr -> ID DEC .)
    WHILE           reduce using rule 37 (expr -> ID DEC .)
    PRINT           reduce using rule 37 (expr -> ID DEC .)
    PROCEDURE       reduce using rule 37 (expr -> ID DEC .)
    RETURN          reduce using rule 37 (expr -> ID DEC .)
    VOID            reduce using rule 37 (expr -> ID DEC .)
    STRING          reduce using rule 37 (expr -> ID DEC .)
    FLOAT           reduce using rule 37 (expr -> ID DEC .)
    INT             reduce using rule 37 (expr -> ID DEC .)
    ID              reduce using rule 37 (expr -> ID DEC .)
    DEC             reduce using rule 37 (expr -> ID DEC .)
    INC             reduce using rule 37 (expr -> ID DEC .)
    NOT             reduce using rule 37 (expr -> ID DEC .)
    LPAREN          reduce using rule 37 (expr -> ID DEC .)
    BLTIN           reduce using rule 37 (expr -> ID DEC .)
    READ            reduce using rule 37 (expr -> ID DEC .)
    FUNCTION        reduce using rule 37 (expr -> ID DEC .)
    ARG             reduce using rule 37 (expr -> ID DEC .)
    FLOATT          reduce using rule 37 (expr -> ID DEC .)
    INTEGER         reduce using rule 37 (expr -> ID DEC .)
    COMMA           reduce using rule 37 (expr -> ID DEC .)
    ELSE            reduce using rule 37 (expr -> ID DEC .)
    SEMI            reduce using rule 37 (expr -> ID DEC .)


state 55

    (38) expr -> ID INC .
    NEWLINE         reduce using rule 38 (expr -> ID INC .)
    OR              reduce using rule 38 (expr -> ID INC .)
    AND             reduce using rule 38 (expr -> ID INC .)
    NE              reduce using rule 38 (expr -> ID INC .)
    EQ              reduce using rule 38 (expr -> ID INC .)
    LE              reduce using rule 38 (expr -> ID INC .)
    LT              reduce using rule 38 (expr -> ID INC .)
    GE              reduce using rule 38 (expr -> ID INC .)
    GT              reduce using rule 38 (expr -> ID INC .)
    POWER           reduce using rule 38 (expr -> ID INC .)
    MODULE          reduce using rule 38 (expr -> ID INC .)
    DIVIDE          reduce using rule 38 (expr -> ID INC .)
    TIMES           reduce using rule 38 (expr -> ID INC .)
    MINUS           reduce using rule 38 (expr -> ID INC .)
    PLUS            reduce using rule 38 (expr -> ID INC .)
    RPAREN          reduce using rule 38 (expr -> ID INC .)
    RBRACKET        reduce using rule 38 (expr -> ID INC .)
    LBRACKET        reduce using rule 38 (expr -> ID INC .)
    IF              reduce using rule 38 (expr -> ID INC .)
    FOR             reduce using rule 38 (expr -> ID INC .)
    WHILE           reduce using rule 38 (expr -> ID INC .)
    PRINT           reduce using rule 38 (expr -> ID INC .)
    PROCEDURE       reduce using rule 38 (expr -> ID INC .)
    RETURN          reduce using rule 38 (expr -> ID INC .)
    VOID            reduce using rule 38 (expr -> ID INC .)
    STRING          reduce using rule 38 (expr -> ID INC .)
    FLOAT           reduce using rule 38 (expr -> ID INC .)
    INT             reduce using rule 38 (expr -> ID INC .)
    ID              reduce using rule 38 (expr -> ID INC .)
    DEC             reduce using rule 38 (expr -> ID INC .)
    INC             reduce using rule 38 (expr -> ID INC .)
    NOT             reduce using rule 38 (expr -> ID INC .)
    LPAREN          reduce using rule 38 (expr -> ID INC .)
    BLTIN           reduce using rule 38 (expr -> ID INC .)
    READ            reduce using rule 38 (expr -> ID INC .)
    FUNCTION        reduce using rule 38 (expr -> ID INC .)
    ARG             reduce using rule 38 (expr -> ID INC .)
    FLOATT          reduce using rule 38 (expr -> ID INC .)
    INTEGER         reduce using rule 38 (expr -> ID INC .)
    COMMA           reduce using rule 38 (expr -> ID INC .)
    ELSE            reduce using rule 38 (expr -> ID INC .)
    SEMI            reduce using rule 38 (expr -> ID INC .)


state 56

    (59) expr -> ID LPAREN . prlist RPAREN
    (67) prlist -> . prlist COMMA STRINGG
    (68) prlist -> . prlist COMMA expr
    (69) prlist -> . STRINGG
    (70) prlist -> . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    STRINGG         shift and go to state 80
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    prlist                         shift and go to state 104
    expr                           shift and go to state 81
    assign                         shift and go to state 66

state 57

    (12) assign -> ID MODEQ . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 105
    assign                         shift and go to state 66

state 58

    (13) assign -> ID DIVEQ . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 106
    assign                         shift and go to state 66

state 59

    (14) assign -> ID MULEQ . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 107
    assign                         shift and go to state 66

state 60

    (15) assign -> ID SUBEQ . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 108
    assign                         shift and go to state 66

state 61

    (16) assign -> ID ADDEQ . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 109
    assign                         shift and go to state 66

state 62

    (17) assign -> ID ASSIGN . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 110
    assign                         shift and go to state 66

state 63

    (39) expr -> DEC ID .
    NEWLINE         reduce using rule 39 (expr -> DEC ID .)
    OR              reduce using rule 39 (expr -> DEC ID .)
    AND             reduce using rule 39 (expr -> DEC ID .)
    NE              reduce using rule 39 (expr -> DEC ID .)
    EQ              reduce using rule 39 (expr -> DEC ID .)
    LE              reduce using rule 39 (expr -> DEC ID .)
    LT              reduce using rule 39 (expr -> DEC ID .)
    GE              reduce using rule 39 (expr -> DEC ID .)
    GT              reduce using rule 39 (expr -> DEC ID .)
    POWER           reduce using rule 39 (expr -> DEC ID .)
    MODULE          reduce using rule 39 (expr -> DEC ID .)
    DIVIDE          reduce using rule 39 (expr -> DEC ID .)
    TIMES           reduce using rule 39 (expr -> DEC ID .)
    MINUS           reduce using rule 39 (expr -> DEC ID .)
    PLUS            reduce using rule 39 (expr -> DEC ID .)
    RPAREN          reduce using rule 39 (expr -> DEC ID .)
    RBRACKET        reduce using rule 39 (expr -> DEC ID .)
    LBRACKET        reduce using rule 39 (expr -> DEC ID .)
    IF              reduce using rule 39 (expr -> DEC ID .)
    FOR             reduce using rule 39 (expr -> DEC ID .)
    WHILE           reduce using rule 39 (expr -> DEC ID .)
    PRINT           reduce using rule 39 (expr -> DEC ID .)
    PROCEDURE       reduce using rule 39 (expr -> DEC ID .)
    RETURN          reduce using rule 39 (expr -> DEC ID .)
    VOID            reduce using rule 39 (expr -> DEC ID .)
    STRING          reduce using rule 39 (expr -> DEC ID .)
    FLOAT           reduce using rule 39 (expr -> DEC ID .)
    INT             reduce using rule 39 (expr -> DEC ID .)
    ID              reduce using rule 39 (expr -> DEC ID .)
    DEC             reduce using rule 39 (expr -> DEC ID .)
    INC             reduce using rule 39 (expr -> DEC ID .)
    NOT             reduce using rule 39 (expr -> DEC ID .)
    LPAREN          reduce using rule 39 (expr -> DEC ID .)
    BLTIN           reduce using rule 39 (expr -> DEC ID .)
    READ            reduce using rule 39 (expr -> DEC ID .)
    FUNCTION        reduce using rule 39 (expr -> DEC ID .)
    ARG             reduce using rule 39 (expr -> DEC ID .)
    FLOATT          reduce using rule 39 (expr -> DEC ID .)
    INTEGER         reduce using rule 39 (expr -> DEC ID .)
    COMMA           reduce using rule 39 (expr -> DEC ID .)
    ELSE            reduce using rule 39 (expr -> DEC ID .)
    SEMI            reduce using rule 39 (expr -> DEC ID .)


state 64

    (40) expr -> INC ID .
    NEWLINE         reduce using rule 40 (expr -> INC ID .)
    OR              reduce using rule 40 (expr -> INC ID .)
    AND             reduce using rule 40 (expr -> INC ID .)
    NE              reduce using rule 40 (expr -> INC ID .)
    EQ              reduce using rule 40 (expr -> INC ID .)
    LE              reduce using rule 40 (expr -> INC ID .)
    LT              reduce using rule 40 (expr -> INC ID .)
    GE              reduce using rule 40 (expr -> INC ID .)
    GT              reduce using rule 40 (expr -> INC ID .)
    POWER           reduce using rule 40 (expr -> INC ID .)
    MODULE          reduce using rule 40 (expr -> INC ID .)
    DIVIDE          reduce using rule 40 (expr -> INC ID .)
    TIMES           reduce using rule 40 (expr -> INC ID .)
    MINUS           reduce using rule 40 (expr -> INC ID .)
    PLUS            reduce using rule 40 (expr -> INC ID .)
    RPAREN          reduce using rule 40 (expr -> INC ID .)
    RBRACKET        reduce using rule 40 (expr -> INC ID .)
    LBRACKET        reduce using rule 40 (expr -> INC ID .)
    IF              reduce using rule 40 (expr -> INC ID .)
    FOR             reduce using rule 40 (expr -> INC ID .)
    WHILE           reduce using rule 40 (expr -> INC ID .)
    PRINT           reduce using rule 40 (expr -> INC ID .)
    PROCEDURE       reduce using rule 40 (expr -> INC ID .)
    RETURN          reduce using rule 40 (expr -> INC ID .)
    VOID            reduce using rule 40 (expr -> INC ID .)
    STRING          reduce using rule 40 (expr -> INC ID .)
    FLOAT           reduce using rule 40 (expr -> INC ID .)
    INT             reduce using rule 40 (expr -> INC ID .)
    ID              reduce using rule 40 (expr -> INC ID .)
    DEC             reduce using rule 40 (expr -> INC ID .)
    INC             reduce using rule 40 (expr -> INC ID .)
    NOT             reduce using rule 40 (expr -> INC ID .)
    LPAREN          reduce using rule 40 (expr -> INC ID .)
    BLTIN           reduce using rule 40 (expr -> INC ID .)
    READ            reduce using rule 40 (expr -> INC ID .)
    FUNCTION        reduce using rule 40 (expr -> INC ID .)
    ARG             reduce using rule 40 (expr -> INC ID .)
    FLOATT          reduce using rule 40 (expr -> INC ID .)
    INTEGER         reduce using rule 40 (expr -> INC ID .)
    COMMA           reduce using rule 40 (expr -> INC ID .)
    ELSE            reduce using rule 40 (expr -> INC ID .)
    SEMI            reduce using rule 40 (expr -> INC ID .)


state 65

    (41) expr -> NOT expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 41 (expr -> NOT expr .)
    OR              reduce using rule 41 (expr -> NOT expr .)
    AND             reduce using rule 41 (expr -> NOT expr .)
    NE              reduce using rule 41 (expr -> NOT expr .)
    EQ              reduce using rule 41 (expr -> NOT expr .)
    LE              reduce using rule 41 (expr -> NOT expr .)
    LT              reduce using rule 41 (expr -> NOT expr .)
    GE              reduce using rule 41 (expr -> NOT expr .)
    GT              reduce using rule 41 (expr -> NOT expr .)
    MODULE          reduce using rule 41 (expr -> NOT expr .)
    DIVIDE          reduce using rule 41 (expr -> NOT expr .)
    TIMES           reduce using rule 41 (expr -> NOT expr .)
    MINUS           reduce using rule 41 (expr -> NOT expr .)
    PLUS            reduce using rule 41 (expr -> NOT expr .)
    RPAREN          reduce using rule 41 (expr -> NOT expr .)
    RBRACKET        reduce using rule 41 (expr -> NOT expr .)
    LBRACKET        reduce using rule 41 (expr -> NOT expr .)
    IF              reduce using rule 41 (expr -> NOT expr .)
    FOR             reduce using rule 41 (expr -> NOT expr .)
    WHILE           reduce using rule 41 (expr -> NOT expr .)
    PRINT           reduce using rule 41 (expr -> NOT expr .)
    PROCEDURE       reduce using rule 41 (expr -> NOT expr .)
    RETURN          reduce using rule 41 (expr -> NOT expr .)
    VOID            reduce using rule 41 (expr -> NOT expr .)
    STRING          reduce using rule 41 (expr -> NOT expr .)
    FLOAT           reduce using rule 41 (expr -> NOT expr .)
    INT             reduce using rule 41 (expr -> NOT expr .)
    ID              reduce using rule 41 (expr -> NOT expr .)
    DEC             reduce using rule 41 (expr -> NOT expr .)
    INC             reduce using rule 41 (expr -> NOT expr .)
    NOT             reduce using rule 41 (expr -> NOT expr .)
    LPAREN          reduce using rule 41 (expr -> NOT expr .)
    BLTIN           reduce using rule 41 (expr -> NOT expr .)
    READ            reduce using rule 41 (expr -> NOT expr .)
    FUNCTION        reduce using rule 41 (expr -> NOT expr .)
    ARG             reduce using rule 41 (expr -> NOT expr .)
    FLOATT          reduce using rule 41 (expr -> NOT expr .)
    INTEGER         reduce using rule 41 (expr -> NOT expr .)
    COMMA           reduce using rule 41 (expr -> NOT expr .)
    ELSE            reduce using rule 41 (expr -> NOT expr .)
    SEMI            reduce using rule 41 (expr -> NOT expr .)
    POWER           shift and go to state 45


state 66

    (62) expr -> assign .
    OR              reduce using rule 62 (expr -> assign .)
    AND             reduce using rule 62 (expr -> assign .)
    NE              reduce using rule 62 (expr -> assign .)
    EQ              reduce using rule 62 (expr -> assign .)
    LE              reduce using rule 62 (expr -> assign .)
    LT              reduce using rule 62 (expr -> assign .)
    GE              reduce using rule 62 (expr -> assign .)
    GT              reduce using rule 62 (expr -> assign .)
    POWER           reduce using rule 62 (expr -> assign .)
    MODULE          reduce using rule 62 (expr -> assign .)
    DIVIDE          reduce using rule 62 (expr -> assign .)
    TIMES           reduce using rule 62 (expr -> assign .)
    MINUS           reduce using rule 62 (expr -> assign .)
    PLUS            reduce using rule 62 (expr -> assign .)
    NEWLINE         reduce using rule 62 (expr -> assign .)
    RPAREN          reduce using rule 62 (expr -> assign .)
    RBRACKET        reduce using rule 62 (expr -> assign .)
    LBRACKET        reduce using rule 62 (expr -> assign .)
    IF              reduce using rule 62 (expr -> assign .)
    FOR             reduce using rule 62 (expr -> assign .)
    WHILE           reduce using rule 62 (expr -> assign .)
    PRINT           reduce using rule 62 (expr -> assign .)
    PROCEDURE       reduce using rule 62 (expr -> assign .)
    RETURN          reduce using rule 62 (expr -> assign .)
    VOID            reduce using rule 62 (expr -> assign .)
    STRING          reduce using rule 62 (expr -> assign .)
    FLOAT           reduce using rule 62 (expr -> assign .)
    INT             reduce using rule 62 (expr -> assign .)
    ID              reduce using rule 62 (expr -> assign .)
    DEC             reduce using rule 62 (expr -> assign .)
    INC             reduce using rule 62 (expr -> assign .)
    NOT             reduce using rule 62 (expr -> assign .)
    LPAREN          reduce using rule 62 (expr -> assign .)
    BLTIN           reduce using rule 62 (expr -> assign .)
    READ            reduce using rule 62 (expr -> assign .)
    FUNCTION        reduce using rule 62 (expr -> assign .)
    ARG             reduce using rule 62 (expr -> assign .)
    FLOATT          reduce using rule 62 (expr -> assign .)
    INTEGER         reduce using rule 62 (expr -> assign .)
    COMMA           reduce using rule 62 (expr -> assign .)
    ELSE            reduce using rule 62 (expr -> assign .)
    SEMI            reduce using rule 62 (expr -> assign .)


state 67

    (50) expr -> MINUS expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 50 (expr -> MINUS expr .)
    OR              reduce using rule 50 (expr -> MINUS expr .)
    AND             reduce using rule 50 (expr -> MINUS expr .)
    NE              reduce using rule 50 (expr -> MINUS expr .)
    EQ              reduce using rule 50 (expr -> MINUS expr .)
    LE              reduce using rule 50 (expr -> MINUS expr .)
    LT              reduce using rule 50 (expr -> MINUS expr .)
    GE              reduce using rule 50 (expr -> MINUS expr .)
    GT              reduce using rule 50 (expr -> MINUS expr .)
    MINUS           reduce using rule 50 (expr -> MINUS expr .)
    PLUS            reduce using rule 50 (expr -> MINUS expr .)
    RPAREN          reduce using rule 50 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 50 (expr -> MINUS expr .)
    LBRACKET        reduce using rule 50 (expr -> MINUS expr .)
    IF              reduce using rule 50 (expr -> MINUS expr .)
    FOR             reduce using rule 50 (expr -> MINUS expr .)
    WHILE           reduce using rule 50 (expr -> MINUS expr .)
    PRINT           reduce using rule 50 (expr -> MINUS expr .)
    PROCEDURE       reduce using rule 50 (expr -> MINUS expr .)
    RETURN          reduce using rule 50 (expr -> MINUS expr .)
    VOID            reduce using rule 50 (expr -> MINUS expr .)
    STRING          reduce using rule 50 (expr -> MINUS expr .)
    FLOAT           reduce using rule 50 (expr -> MINUS expr .)
    INT             reduce using rule 50 (expr -> MINUS expr .)
    ID              reduce using rule 50 (expr -> MINUS expr .)
    DEC             reduce using rule 50 (expr -> MINUS expr .)
    INC             reduce using rule 50 (expr -> MINUS expr .)
    NOT             reduce using rule 50 (expr -> MINUS expr .)
    LPAREN          reduce using rule 50 (expr -> MINUS expr .)
    BLTIN           reduce using rule 50 (expr -> MINUS expr .)
    READ            reduce using rule 50 (expr -> MINUS expr .)
    FUNCTION        reduce using rule 50 (expr -> MINUS expr .)
    ARG             reduce using rule 50 (expr -> MINUS expr .)
    FLOATT          reduce using rule 50 (expr -> MINUS expr .)
    INTEGER         reduce using rule 50 (expr -> MINUS expr .)
    COMMA           reduce using rule 50 (expr -> MINUS expr .)
    ELSE            reduce using rule 50 (expr -> MINUS expr .)
    SEMI            reduce using rule 50 (expr -> MINUS expr .)
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48


state 68

    (57) expr -> LPAREN expr . RPAREN
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    RPAREN          shift and go to state 111
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 69

    (58) expr -> BLTIN LPAREN . expr RPAREN
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 112
    assign                         shift and go to state 66

state 70

    (60) expr -> READ LPAREN . ID RPAREN
    ID              shift and go to state 113


state 71

    (61) expr -> FUNCTION begin . LPAREN arglist RPAREN
    LPAREN          shift and go to state 114


state 72

    (20) stmt -> LBRACKET stmtlist . RBRACKET
    (33) stmtlist -> stmtlist . stmt
    (34) stmtlist -> stmtlist . NEWLINE
    (20) stmt -> . LBRACKET stmtlist RBRACKET
    (21) stmt -> . IF LPAREN cond RPAREN stmt end ELSE stmt end
    (22) stmt -> . IF LPAREN cond RPAREN stmt end
    (23) stmt -> . FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end
    (24) stmt -> . WHILE LPAREN cond RPAREN stmt end
    (25) stmt -> . PRINT prlist
    (26) stmt -> . PROCEDURE begin LPAREN arglist RPAREN
    (27) stmt -> . RETURN expr
    (28) stmt -> . type ID
    (29) stmt -> . expr
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    RBRACKET        shift and go to state 115
    NEWLINE         shift and go to state 117
    LBRACKET        shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    WHILE           shift and go to state 24
    PRINT           shift and go to state 25
    PROCEDURE       shift and go to state 26
    RETURN          shift and go to state 27
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    stmt                           shift and go to state 116
    expr                           shift and go to state 75
    type                           shift and go to state 28
    assign                         shift and go to state 66

state 73

    (35) stmtlist -> stmt .
    RBRACKET        reduce using rule 35 (stmtlist -> stmt .)
    NEWLINE         reduce using rule 35 (stmtlist -> stmt .)
    LBRACKET        reduce using rule 35 (stmtlist -> stmt .)
    IF              reduce using rule 35 (stmtlist -> stmt .)
    FOR             reduce using rule 35 (stmtlist -> stmt .)
    WHILE           reduce using rule 35 (stmtlist -> stmt .)
    PRINT           reduce using rule 35 (stmtlist -> stmt .)
    PROCEDURE       reduce using rule 35 (stmtlist -> stmt .)
    RETURN          reduce using rule 35 (stmtlist -> stmt .)
    VOID            reduce using rule 35 (stmtlist -> stmt .)
    STRING          reduce using rule 35 (stmtlist -> stmt .)
    FLOAT           reduce using rule 35 (stmtlist -> stmt .)
    INT             reduce using rule 35 (stmtlist -> stmt .)
    ID              reduce using rule 35 (stmtlist -> stmt .)
    DEC             reduce using rule 35 (stmtlist -> stmt .)
    INC             reduce using rule 35 (stmtlist -> stmt .)
    NOT             reduce using rule 35 (stmtlist -> stmt .)
    MINUS           reduce using rule 35 (stmtlist -> stmt .)
    LPAREN          reduce using rule 35 (stmtlist -> stmt .)
    BLTIN           reduce using rule 35 (stmtlist -> stmt .)
    READ            reduce using rule 35 (stmtlist -> stmt .)
    FUNCTION        reduce using rule 35 (stmtlist -> stmt .)
    ARG             reduce using rule 35 (stmtlist -> stmt .)
    FLOATT          reduce using rule 35 (stmtlist -> stmt .)
    INTEGER         reduce using rule 35 (stmtlist -> stmt .)


state 74

    (36) stmtlist -> NEWLINE .
    RBRACKET        reduce using rule 36 (stmtlist -> NEWLINE .)
    NEWLINE         reduce using rule 36 (stmtlist -> NEWLINE .)
    LBRACKET        reduce using rule 36 (stmtlist -> NEWLINE .)
    IF              reduce using rule 36 (stmtlist -> NEWLINE .)
    FOR             reduce using rule 36 (stmtlist -> NEWLINE .)
    WHILE           reduce using rule 36 (stmtlist -> NEWLINE .)
    PRINT           reduce using rule 36 (stmtlist -> NEWLINE .)
    PROCEDURE       reduce using rule 36 (stmtlist -> NEWLINE .)
    RETURN          reduce using rule 36 (stmtlist -> NEWLINE .)
    VOID            reduce using rule 36 (stmtlist -> NEWLINE .)
    STRING          reduce using rule 36 (stmtlist -> NEWLINE .)
    FLOAT           reduce using rule 36 (stmtlist -> NEWLINE .)
    INT             reduce using rule 36 (stmtlist -> NEWLINE .)
    ID              reduce using rule 36 (stmtlist -> NEWLINE .)
    DEC             reduce using rule 36 (stmtlist -> NEWLINE .)
    INC             reduce using rule 36 (stmtlist -> NEWLINE .)
    NOT             reduce using rule 36 (stmtlist -> NEWLINE .)
    MINUS           reduce using rule 36 (stmtlist -> NEWLINE .)
    LPAREN          reduce using rule 36 (stmtlist -> NEWLINE .)
    BLTIN           reduce using rule 36 (stmtlist -> NEWLINE .)
    READ            reduce using rule 36 (stmtlist -> NEWLINE .)
    FUNCTION        reduce using rule 36 (stmtlist -> NEWLINE .)
    ARG             reduce using rule 36 (stmtlist -> NEWLINE .)
    FLOATT          reduce using rule 36 (stmtlist -> NEWLINE .)
    INTEGER         reduce using rule 36 (stmtlist -> NEWLINE .)


state 75

    (29) stmt -> expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 29 (stmt -> expr .)
    NEWLINE         reduce using rule 29 (stmt -> expr .)
    LBRACKET        reduce using rule 29 (stmt -> expr .)
    IF              reduce using rule 29 (stmt -> expr .)
    FOR             reduce using rule 29 (stmt -> expr .)
    WHILE           reduce using rule 29 (stmt -> expr .)
    PRINT           reduce using rule 29 (stmt -> expr .)
    PROCEDURE       reduce using rule 29 (stmt -> expr .)
    RETURN          reduce using rule 29 (stmt -> expr .)
    VOID            reduce using rule 29 (stmt -> expr .)
    STRING          reduce using rule 29 (stmt -> expr .)
    FLOAT           reduce using rule 29 (stmt -> expr .)
    INT             reduce using rule 29 (stmt -> expr .)
    ID              reduce using rule 29 (stmt -> expr .)
    DEC             reduce using rule 29 (stmt -> expr .)
    INC             reduce using rule 29 (stmt -> expr .)
    NOT             reduce using rule 29 (stmt -> expr .)
    LPAREN          reduce using rule 29 (stmt -> expr .)
    BLTIN           reduce using rule 29 (stmt -> expr .)
    READ            reduce using rule 29 (stmt -> expr .)
    FUNCTION        reduce using rule 29 (stmt -> expr .)
    ARG             reduce using rule 29 (stmt -> expr .)
    FLOATT          reduce using rule 29 (stmt -> expr .)
    INTEGER         reduce using rule 29 (stmt -> expr .)
    ELSE            reduce using rule 29 (stmt -> expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 76

    (21) stmt -> IF LPAREN . cond RPAREN stmt end ELSE stmt end
    (22) stmt -> IF LPAREN . cond RPAREN stmt end
    (30) cond -> . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    cond                           shift and go to state 118
    expr                           shift and go to state 119
    assign                         shift and go to state 66

state 77

    (23) stmt -> FOR LPAREN . cond SEMI cond SEMI cond RPAREN stmt end
    (30) cond -> . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    cond                           shift and go to state 120
    expr                           shift and go to state 119
    assign                         shift and go to state 66

state 78

    (24) stmt -> WHILE LPAREN . cond RPAREN stmt end
    (30) cond -> . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    cond                           shift and go to state 121
    expr                           shift and go to state 119
    assign                         shift and go to state 66

state 79

    (25) stmt -> PRINT prlist .
    (67) prlist -> prlist . COMMA STRINGG
    (68) prlist -> prlist . COMMA expr
    NEWLINE         reduce using rule 25 (stmt -> PRINT prlist .)
    RBRACKET        reduce using rule 25 (stmt -> PRINT prlist .)
    LBRACKET        reduce using rule 25 (stmt -> PRINT prlist .)
    IF              reduce using rule 25 (stmt -> PRINT prlist .)
    FOR             reduce using rule 25 (stmt -> PRINT prlist .)
    WHILE           reduce using rule 25 (stmt -> PRINT prlist .)
    PRINT           reduce using rule 25 (stmt -> PRINT prlist .)
    PROCEDURE       reduce using rule 25 (stmt -> PRINT prlist .)
    RETURN          reduce using rule 25 (stmt -> PRINT prlist .)
    VOID            reduce using rule 25 (stmt -> PRINT prlist .)
    STRING          reduce using rule 25 (stmt -> PRINT prlist .)
    FLOAT           reduce using rule 25 (stmt -> PRINT prlist .)
    INT             reduce using rule 25 (stmt -> PRINT prlist .)
    ID              reduce using rule 25 (stmt -> PRINT prlist .)
    DEC             reduce using rule 25 (stmt -> PRINT prlist .)
    INC             reduce using rule 25 (stmt -> PRINT prlist .)
    NOT             reduce using rule 25 (stmt -> PRINT prlist .)
    MINUS           reduce using rule 25 (stmt -> PRINT prlist .)
    LPAREN          reduce using rule 25 (stmt -> PRINT prlist .)
    BLTIN           reduce using rule 25 (stmt -> PRINT prlist .)
    READ            reduce using rule 25 (stmt -> PRINT prlist .)
    FUNCTION        reduce using rule 25 (stmt -> PRINT prlist .)
    ARG             reduce using rule 25 (stmt -> PRINT prlist .)
    FLOATT          reduce using rule 25 (stmt -> PRINT prlist .)
    INTEGER         reduce using rule 25 (stmt -> PRINT prlist .)
    ELSE            reduce using rule 25 (stmt -> PRINT prlist .)
    COMMA           shift and go to state 122


state 80

    (69) prlist -> STRINGG .
    COMMA           reduce using rule 69 (prlist -> STRINGG .)
    NEWLINE         reduce using rule 69 (prlist -> STRINGG .)
    RBRACKET        reduce using rule 69 (prlist -> STRINGG .)
    LBRACKET        reduce using rule 69 (prlist -> STRINGG .)
    IF              reduce using rule 69 (prlist -> STRINGG .)
    FOR             reduce using rule 69 (prlist -> STRINGG .)
    WHILE           reduce using rule 69 (prlist -> STRINGG .)
    PRINT           reduce using rule 69 (prlist -> STRINGG .)
    PROCEDURE       reduce using rule 69 (prlist -> STRINGG .)
    RETURN          reduce using rule 69 (prlist -> STRINGG .)
    VOID            reduce using rule 69 (prlist -> STRINGG .)
    STRING          reduce using rule 69 (prlist -> STRINGG .)
    FLOAT           reduce using rule 69 (prlist -> STRINGG .)
    INT             reduce using rule 69 (prlist -> STRINGG .)
    ID              reduce using rule 69 (prlist -> STRINGG .)
    DEC             reduce using rule 69 (prlist -> STRINGG .)
    INC             reduce using rule 69 (prlist -> STRINGG .)
    NOT             reduce using rule 69 (prlist -> STRINGG .)
    MINUS           reduce using rule 69 (prlist -> STRINGG .)
    LPAREN          reduce using rule 69 (prlist -> STRINGG .)
    BLTIN           reduce using rule 69 (prlist -> STRINGG .)
    READ            reduce using rule 69 (prlist -> STRINGG .)
    FUNCTION        reduce using rule 69 (prlist -> STRINGG .)
    ARG             reduce using rule 69 (prlist -> STRINGG .)
    FLOATT          reduce using rule 69 (prlist -> STRINGG .)
    INTEGER         reduce using rule 69 (prlist -> STRINGG .)
    ELSE            reduce using rule 69 (prlist -> STRINGG .)
    RPAREN          reduce using rule 69 (prlist -> STRINGG .)


state 81

    (70) prlist -> expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 70 (prlist -> expr .)
    NEWLINE         reduce using rule 70 (prlist -> expr .)
    RBRACKET        reduce using rule 70 (prlist -> expr .)
    LBRACKET        reduce using rule 70 (prlist -> expr .)
    IF              reduce using rule 70 (prlist -> expr .)
    FOR             reduce using rule 70 (prlist -> expr .)
    WHILE           reduce using rule 70 (prlist -> expr .)
    PRINT           reduce using rule 70 (prlist -> expr .)
    PROCEDURE       reduce using rule 70 (prlist -> expr .)
    RETURN          reduce using rule 70 (prlist -> expr .)
    VOID            reduce using rule 70 (prlist -> expr .)
    STRING          reduce using rule 70 (prlist -> expr .)
    FLOAT           reduce using rule 70 (prlist -> expr .)
    INT             reduce using rule 70 (prlist -> expr .)
    ID              reduce using rule 70 (prlist -> expr .)
    DEC             reduce using rule 70 (prlist -> expr .)
    INC             reduce using rule 70 (prlist -> expr .)
    NOT             reduce using rule 70 (prlist -> expr .)
    LPAREN          reduce using rule 70 (prlist -> expr .)
    BLTIN           reduce using rule 70 (prlist -> expr .)
    READ            reduce using rule 70 (prlist -> expr .)
    FUNCTION        reduce using rule 70 (prlist -> expr .)
    ARG             reduce using rule 70 (prlist -> expr .)
    FLOATT          reduce using rule 70 (prlist -> expr .)
    INTEGER         reduce using rule 70 (prlist -> expr .)
    ELSE            reduce using rule 70 (prlist -> expr .)
    RPAREN          reduce using rule 70 (prlist -> expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 82

    (26) stmt -> PROCEDURE begin . LPAREN arglist RPAREN
    LPAREN          shift and go to state 123


state 83

    (27) stmt -> RETURN expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 27 (stmt -> RETURN expr .)
    RBRACKET        reduce using rule 27 (stmt -> RETURN expr .)
    LBRACKET        reduce using rule 27 (stmt -> RETURN expr .)
    IF              reduce using rule 27 (stmt -> RETURN expr .)
    FOR             reduce using rule 27 (stmt -> RETURN expr .)
    WHILE           reduce using rule 27 (stmt -> RETURN expr .)
    PRINT           reduce using rule 27 (stmt -> RETURN expr .)
    PROCEDURE       reduce using rule 27 (stmt -> RETURN expr .)
    RETURN          reduce using rule 27 (stmt -> RETURN expr .)
    VOID            reduce using rule 27 (stmt -> RETURN expr .)
    STRING          reduce using rule 27 (stmt -> RETURN expr .)
    FLOAT           reduce using rule 27 (stmt -> RETURN expr .)
    INT             reduce using rule 27 (stmt -> RETURN expr .)
    ID              reduce using rule 27 (stmt -> RETURN expr .)
    DEC             reduce using rule 27 (stmt -> RETURN expr .)
    INC             reduce using rule 27 (stmt -> RETURN expr .)
    NOT             reduce using rule 27 (stmt -> RETURN expr .)
    LPAREN          reduce using rule 27 (stmt -> RETURN expr .)
    BLTIN           reduce using rule 27 (stmt -> RETURN expr .)
    READ            reduce using rule 27 (stmt -> RETURN expr .)
    FUNCTION        reduce using rule 27 (stmt -> RETURN expr .)
    ARG             reduce using rule 27 (stmt -> RETURN expr .)
    FLOATT          reduce using rule 27 (stmt -> RETURN expr .)
    INTEGER         reduce using rule 27 (stmt -> RETURN expr .)
    ELSE            reduce using rule 27 (stmt -> RETURN expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 84

    (28) stmt -> type ID .
    NEWLINE         reduce using rule 28 (stmt -> type ID .)
    RBRACKET        reduce using rule 28 (stmt -> type ID .)
    LBRACKET        reduce using rule 28 (stmt -> type ID .)
    IF              reduce using rule 28 (stmt -> type ID .)
    FOR             reduce using rule 28 (stmt -> type ID .)
    WHILE           reduce using rule 28 (stmt -> type ID .)
    PRINT           reduce using rule 28 (stmt -> type ID .)
    PROCEDURE       reduce using rule 28 (stmt -> type ID .)
    RETURN          reduce using rule 28 (stmt -> type ID .)
    VOID            reduce using rule 28 (stmt -> type ID .)
    STRING          reduce using rule 28 (stmt -> type ID .)
    FLOAT           reduce using rule 28 (stmt -> type ID .)
    INT             reduce using rule 28 (stmt -> type ID .)
    ID              reduce using rule 28 (stmt -> type ID .)
    DEC             reduce using rule 28 (stmt -> type ID .)
    INC             reduce using rule 28 (stmt -> type ID .)
    NOT             reduce using rule 28 (stmt -> type ID .)
    MINUS           reduce using rule 28 (stmt -> type ID .)
    LPAREN          reduce using rule 28 (stmt -> type ID .)
    BLTIN           reduce using rule 28 (stmt -> type ID .)
    READ            reduce using rule 28 (stmt -> type ID .)
    FUNCTION        reduce using rule 28 (stmt -> type ID .)
    ARG             reduce using rule 28 (stmt -> type ID .)
    FLOATT          reduce using rule 28 (stmt -> type ID .)
    INTEGER         reduce using rule 28 (stmt -> type ID .)
    ELSE            reduce using rule 28 (stmt -> type ID .)


state 85

    (18) defn -> PROC procname . LPAREN formalopt RPAREN stmt
    LPAREN          shift and go to state 124


state 86

    (78) procname -> PROCEDURE .
    LPAREN          reduce using rule 78 (procname -> PROCEDURE .)


state 87

    (79) procname -> FUNCTION .
    LPAREN          reduce using rule 79 (procname -> FUNCTION .)


state 88

    (80) procname -> ID .
    LPAREN          reduce using rule 80 (procname -> ID .)


state 89

    (19) defn -> FUNC procname . LPAREN formalopt RPAREN type stmt
    LPAREN          shift and go to state 125


state 90

    (42) expr -> expr OR expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 42 (expr -> expr OR expr .)
    OR              reduce using rule 42 (expr -> expr OR expr .)
    RPAREN          reduce using rule 42 (expr -> expr OR expr .)
    RBRACKET        reduce using rule 42 (expr -> expr OR expr .)
    LBRACKET        reduce using rule 42 (expr -> expr OR expr .)
    IF              reduce using rule 42 (expr -> expr OR expr .)
    FOR             reduce using rule 42 (expr -> expr OR expr .)
    WHILE           reduce using rule 42 (expr -> expr OR expr .)
    PRINT           reduce using rule 42 (expr -> expr OR expr .)
    PROCEDURE       reduce using rule 42 (expr -> expr OR expr .)
    RETURN          reduce using rule 42 (expr -> expr OR expr .)
    VOID            reduce using rule 42 (expr -> expr OR expr .)
    STRING          reduce using rule 42 (expr -> expr OR expr .)
    FLOAT           reduce using rule 42 (expr -> expr OR expr .)
    INT             reduce using rule 42 (expr -> expr OR expr .)
    ID              reduce using rule 42 (expr -> expr OR expr .)
    DEC             reduce using rule 42 (expr -> expr OR expr .)
    INC             reduce using rule 42 (expr -> expr OR expr .)
    NOT             reduce using rule 42 (expr -> expr OR expr .)
    LPAREN          reduce using rule 42 (expr -> expr OR expr .)
    BLTIN           reduce using rule 42 (expr -> expr OR expr .)
    READ            reduce using rule 42 (expr -> expr OR expr .)
    FUNCTION        reduce using rule 42 (expr -> expr OR expr .)
    ARG             reduce using rule 42 (expr -> expr OR expr .)
    FLOATT          reduce using rule 42 (expr -> expr OR expr .)
    INTEGER         reduce using rule 42 (expr -> expr OR expr .)
    COMMA           reduce using rule 42 (expr -> expr OR expr .)
    ELSE            reduce using rule 42 (expr -> expr OR expr .)
    SEMI            reduce using rule 42 (expr -> expr OR expr .)
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 91

    (43) expr -> expr AND expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 43 (expr -> expr AND expr .)
    OR              reduce using rule 43 (expr -> expr AND expr .)
    AND             reduce using rule 43 (expr -> expr AND expr .)
    RPAREN          reduce using rule 43 (expr -> expr AND expr .)
    RBRACKET        reduce using rule 43 (expr -> expr AND expr .)
    LBRACKET        reduce using rule 43 (expr -> expr AND expr .)
    IF              reduce using rule 43 (expr -> expr AND expr .)
    FOR             reduce using rule 43 (expr -> expr AND expr .)
    WHILE           reduce using rule 43 (expr -> expr AND expr .)
    PRINT           reduce using rule 43 (expr -> expr AND expr .)
    PROCEDURE       reduce using rule 43 (expr -> expr AND expr .)
    RETURN          reduce using rule 43 (expr -> expr AND expr .)
    VOID            reduce using rule 43 (expr -> expr AND expr .)
    STRING          reduce using rule 43 (expr -> expr AND expr .)
    FLOAT           reduce using rule 43 (expr -> expr AND expr .)
    INT             reduce using rule 43 (expr -> expr AND expr .)
    ID              reduce using rule 43 (expr -> expr AND expr .)
    DEC             reduce using rule 43 (expr -> expr AND expr .)
    INC             reduce using rule 43 (expr -> expr AND expr .)
    NOT             reduce using rule 43 (expr -> expr AND expr .)
    LPAREN          reduce using rule 43 (expr -> expr AND expr .)
    BLTIN           reduce using rule 43 (expr -> expr AND expr .)
    READ            reduce using rule 43 (expr -> expr AND expr .)
    FUNCTION        reduce using rule 43 (expr -> expr AND expr .)
    ARG             reduce using rule 43 (expr -> expr AND expr .)
    FLOATT          reduce using rule 43 (expr -> expr AND expr .)
    INTEGER         reduce using rule 43 (expr -> expr AND expr .)
    COMMA           reduce using rule 43 (expr -> expr AND expr .)
    ELSE            reduce using rule 43 (expr -> expr AND expr .)
    SEMI            reduce using rule 43 (expr -> expr AND expr .)
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 92

    (44) expr -> expr NE expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 44 (expr -> expr NE expr .)
    OR              reduce using rule 44 (expr -> expr NE expr .)
    AND             reduce using rule 44 (expr -> expr NE expr .)
    NE              reduce using rule 44 (expr -> expr NE expr .)
    EQ              reduce using rule 44 (expr -> expr NE expr .)
    LE              reduce using rule 44 (expr -> expr NE expr .)
    LT              reduce using rule 44 (expr -> expr NE expr .)
    GE              reduce using rule 44 (expr -> expr NE expr .)
    GT              reduce using rule 44 (expr -> expr NE expr .)
    RPAREN          reduce using rule 44 (expr -> expr NE expr .)
    RBRACKET        reduce using rule 44 (expr -> expr NE expr .)
    LBRACKET        reduce using rule 44 (expr -> expr NE expr .)
    IF              reduce using rule 44 (expr -> expr NE expr .)
    FOR             reduce using rule 44 (expr -> expr NE expr .)
    WHILE           reduce using rule 44 (expr -> expr NE expr .)
    PRINT           reduce using rule 44 (expr -> expr NE expr .)
    PROCEDURE       reduce using rule 44 (expr -> expr NE expr .)
    RETURN          reduce using rule 44 (expr -> expr NE expr .)
    VOID            reduce using rule 44 (expr -> expr NE expr .)
    STRING          reduce using rule 44 (expr -> expr NE expr .)
    FLOAT           reduce using rule 44 (expr -> expr NE expr .)
    INT             reduce using rule 44 (expr -> expr NE expr .)
    ID              reduce using rule 44 (expr -> expr NE expr .)
    DEC             reduce using rule 44 (expr -> expr NE expr .)
    INC             reduce using rule 44 (expr -> expr NE expr .)
    NOT             reduce using rule 44 (expr -> expr NE expr .)
    LPAREN          reduce using rule 44 (expr -> expr NE expr .)
    BLTIN           reduce using rule 44 (expr -> expr NE expr .)
    READ            reduce using rule 44 (expr -> expr NE expr .)
    FUNCTION        reduce using rule 44 (expr -> expr NE expr .)
    ARG             reduce using rule 44 (expr -> expr NE expr .)
    FLOATT          reduce using rule 44 (expr -> expr NE expr .)
    INTEGER         reduce using rule 44 (expr -> expr NE expr .)
    COMMA           reduce using rule 44 (expr -> expr NE expr .)
    ELSE            reduce using rule 44 (expr -> expr NE expr .)
    SEMI            reduce using rule 44 (expr -> expr NE expr .)
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 93

    (45) expr -> expr EQ expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 45 (expr -> expr EQ expr .)
    OR              reduce using rule 45 (expr -> expr EQ expr .)
    AND             reduce using rule 45 (expr -> expr EQ expr .)
    NE              reduce using rule 45 (expr -> expr EQ expr .)
    EQ              reduce using rule 45 (expr -> expr EQ expr .)
    LE              reduce using rule 45 (expr -> expr EQ expr .)
    LT              reduce using rule 45 (expr -> expr EQ expr .)
    GE              reduce using rule 45 (expr -> expr EQ expr .)
    GT              reduce using rule 45 (expr -> expr EQ expr .)
    RPAREN          reduce using rule 45 (expr -> expr EQ expr .)
    RBRACKET        reduce using rule 45 (expr -> expr EQ expr .)
    LBRACKET        reduce using rule 45 (expr -> expr EQ expr .)
    IF              reduce using rule 45 (expr -> expr EQ expr .)
    FOR             reduce using rule 45 (expr -> expr EQ expr .)
    WHILE           reduce using rule 45 (expr -> expr EQ expr .)
    PRINT           reduce using rule 45 (expr -> expr EQ expr .)
    PROCEDURE       reduce using rule 45 (expr -> expr EQ expr .)
    RETURN          reduce using rule 45 (expr -> expr EQ expr .)
    VOID            reduce using rule 45 (expr -> expr EQ expr .)
    STRING          reduce using rule 45 (expr -> expr EQ expr .)
    FLOAT           reduce using rule 45 (expr -> expr EQ expr .)
    INT             reduce using rule 45 (expr -> expr EQ expr .)
    ID              reduce using rule 45 (expr -> expr EQ expr .)
    DEC             reduce using rule 45 (expr -> expr EQ expr .)
    INC             reduce using rule 45 (expr -> expr EQ expr .)
    NOT             reduce using rule 45 (expr -> expr EQ expr .)
    LPAREN          reduce using rule 45 (expr -> expr EQ expr .)
    BLTIN           reduce using rule 45 (expr -> expr EQ expr .)
    READ            reduce using rule 45 (expr -> expr EQ expr .)
    FUNCTION        reduce using rule 45 (expr -> expr EQ expr .)
    ARG             reduce using rule 45 (expr -> expr EQ expr .)
    FLOATT          reduce using rule 45 (expr -> expr EQ expr .)
    INTEGER         reduce using rule 45 (expr -> expr EQ expr .)
    COMMA           reduce using rule 45 (expr -> expr EQ expr .)
    ELSE            reduce using rule 45 (expr -> expr EQ expr .)
    SEMI            reduce using rule 45 (expr -> expr EQ expr .)
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 94

    (46) expr -> expr LE expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 46 (expr -> expr LE expr .)
    OR              reduce using rule 46 (expr -> expr LE expr .)
    AND             reduce using rule 46 (expr -> expr LE expr .)
    NE              reduce using rule 46 (expr -> expr LE expr .)
    EQ              reduce using rule 46 (expr -> expr LE expr .)
    LE              reduce using rule 46 (expr -> expr LE expr .)
    LT              reduce using rule 46 (expr -> expr LE expr .)
    GE              reduce using rule 46 (expr -> expr LE expr .)
    GT              reduce using rule 46 (expr -> expr LE expr .)
    RPAREN          reduce using rule 46 (expr -> expr LE expr .)
    RBRACKET        reduce using rule 46 (expr -> expr LE expr .)
    LBRACKET        reduce using rule 46 (expr -> expr LE expr .)
    IF              reduce using rule 46 (expr -> expr LE expr .)
    FOR             reduce using rule 46 (expr -> expr LE expr .)
    WHILE           reduce using rule 46 (expr -> expr LE expr .)
    PRINT           reduce using rule 46 (expr -> expr LE expr .)
    PROCEDURE       reduce using rule 46 (expr -> expr LE expr .)
    RETURN          reduce using rule 46 (expr -> expr LE expr .)
    VOID            reduce using rule 46 (expr -> expr LE expr .)
    STRING          reduce using rule 46 (expr -> expr LE expr .)
    FLOAT           reduce using rule 46 (expr -> expr LE expr .)
    INT             reduce using rule 46 (expr -> expr LE expr .)
    ID              reduce using rule 46 (expr -> expr LE expr .)
    DEC             reduce using rule 46 (expr -> expr LE expr .)
    INC             reduce using rule 46 (expr -> expr LE expr .)
    NOT             reduce using rule 46 (expr -> expr LE expr .)
    LPAREN          reduce using rule 46 (expr -> expr LE expr .)
    BLTIN           reduce using rule 46 (expr -> expr LE expr .)
    READ            reduce using rule 46 (expr -> expr LE expr .)
    FUNCTION        reduce using rule 46 (expr -> expr LE expr .)
    ARG             reduce using rule 46 (expr -> expr LE expr .)
    FLOATT          reduce using rule 46 (expr -> expr LE expr .)
    INTEGER         reduce using rule 46 (expr -> expr LE expr .)
    COMMA           reduce using rule 46 (expr -> expr LE expr .)
    ELSE            reduce using rule 46 (expr -> expr LE expr .)
    SEMI            reduce using rule 46 (expr -> expr LE expr .)
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 95

    (47) expr -> expr LT expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 47 (expr -> expr LT expr .)
    OR              reduce using rule 47 (expr -> expr LT expr .)
    AND             reduce using rule 47 (expr -> expr LT expr .)
    NE              reduce using rule 47 (expr -> expr LT expr .)
    EQ              reduce using rule 47 (expr -> expr LT expr .)
    LE              reduce using rule 47 (expr -> expr LT expr .)
    LT              reduce using rule 47 (expr -> expr LT expr .)
    GE              reduce using rule 47 (expr -> expr LT expr .)
    GT              reduce using rule 47 (expr -> expr LT expr .)
    RPAREN          reduce using rule 47 (expr -> expr LT expr .)
    RBRACKET        reduce using rule 47 (expr -> expr LT expr .)
    LBRACKET        reduce using rule 47 (expr -> expr LT expr .)
    IF              reduce using rule 47 (expr -> expr LT expr .)
    FOR             reduce using rule 47 (expr -> expr LT expr .)
    WHILE           reduce using rule 47 (expr -> expr LT expr .)
    PRINT           reduce using rule 47 (expr -> expr LT expr .)
    PROCEDURE       reduce using rule 47 (expr -> expr LT expr .)
    RETURN          reduce using rule 47 (expr -> expr LT expr .)
    VOID            reduce using rule 47 (expr -> expr LT expr .)
    STRING          reduce using rule 47 (expr -> expr LT expr .)
    FLOAT           reduce using rule 47 (expr -> expr LT expr .)
    INT             reduce using rule 47 (expr -> expr LT expr .)
    ID              reduce using rule 47 (expr -> expr LT expr .)
    DEC             reduce using rule 47 (expr -> expr LT expr .)
    INC             reduce using rule 47 (expr -> expr LT expr .)
    NOT             reduce using rule 47 (expr -> expr LT expr .)
    LPAREN          reduce using rule 47 (expr -> expr LT expr .)
    BLTIN           reduce using rule 47 (expr -> expr LT expr .)
    READ            reduce using rule 47 (expr -> expr LT expr .)
    FUNCTION        reduce using rule 47 (expr -> expr LT expr .)
    ARG             reduce using rule 47 (expr -> expr LT expr .)
    FLOATT          reduce using rule 47 (expr -> expr LT expr .)
    INTEGER         reduce using rule 47 (expr -> expr LT expr .)
    COMMA           reduce using rule 47 (expr -> expr LT expr .)
    ELSE            reduce using rule 47 (expr -> expr LT expr .)
    SEMI            reduce using rule 47 (expr -> expr LT expr .)
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 96

    (48) expr -> expr GE expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 48 (expr -> expr GE expr .)
    OR              reduce using rule 48 (expr -> expr GE expr .)
    AND             reduce using rule 48 (expr -> expr GE expr .)
    NE              reduce using rule 48 (expr -> expr GE expr .)
    EQ              reduce using rule 48 (expr -> expr GE expr .)
    LE              reduce using rule 48 (expr -> expr GE expr .)
    LT              reduce using rule 48 (expr -> expr GE expr .)
    GE              reduce using rule 48 (expr -> expr GE expr .)
    GT              reduce using rule 48 (expr -> expr GE expr .)
    RPAREN          reduce using rule 48 (expr -> expr GE expr .)
    RBRACKET        reduce using rule 48 (expr -> expr GE expr .)
    LBRACKET        reduce using rule 48 (expr -> expr GE expr .)
    IF              reduce using rule 48 (expr -> expr GE expr .)
    FOR             reduce using rule 48 (expr -> expr GE expr .)
    WHILE           reduce using rule 48 (expr -> expr GE expr .)
    PRINT           reduce using rule 48 (expr -> expr GE expr .)
    PROCEDURE       reduce using rule 48 (expr -> expr GE expr .)
    RETURN          reduce using rule 48 (expr -> expr GE expr .)
    VOID            reduce using rule 48 (expr -> expr GE expr .)
    STRING          reduce using rule 48 (expr -> expr GE expr .)
    FLOAT           reduce using rule 48 (expr -> expr GE expr .)
    INT             reduce using rule 48 (expr -> expr GE expr .)
    ID              reduce using rule 48 (expr -> expr GE expr .)
    DEC             reduce using rule 48 (expr -> expr GE expr .)
    INC             reduce using rule 48 (expr -> expr GE expr .)
    NOT             reduce using rule 48 (expr -> expr GE expr .)
    LPAREN          reduce using rule 48 (expr -> expr GE expr .)
    BLTIN           reduce using rule 48 (expr -> expr GE expr .)
    READ            reduce using rule 48 (expr -> expr GE expr .)
    FUNCTION        reduce using rule 48 (expr -> expr GE expr .)
    ARG             reduce using rule 48 (expr -> expr GE expr .)
    FLOATT          reduce using rule 48 (expr -> expr GE expr .)
    INTEGER         reduce using rule 48 (expr -> expr GE expr .)
    COMMA           reduce using rule 48 (expr -> expr GE expr .)
    ELSE            reduce using rule 48 (expr -> expr GE expr .)
    SEMI            reduce using rule 48 (expr -> expr GE expr .)
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 97

    (49) expr -> expr GT expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 49 (expr -> expr GT expr .)
    OR              reduce using rule 49 (expr -> expr GT expr .)
    AND             reduce using rule 49 (expr -> expr GT expr .)
    NE              reduce using rule 49 (expr -> expr GT expr .)
    EQ              reduce using rule 49 (expr -> expr GT expr .)
    LE              reduce using rule 49 (expr -> expr GT expr .)
    LT              reduce using rule 49 (expr -> expr GT expr .)
    GE              reduce using rule 49 (expr -> expr GT expr .)
    GT              reduce using rule 49 (expr -> expr GT expr .)
    RPAREN          reduce using rule 49 (expr -> expr GT expr .)
    RBRACKET        reduce using rule 49 (expr -> expr GT expr .)
    LBRACKET        reduce using rule 49 (expr -> expr GT expr .)
    IF              reduce using rule 49 (expr -> expr GT expr .)
    FOR             reduce using rule 49 (expr -> expr GT expr .)
    WHILE           reduce using rule 49 (expr -> expr GT expr .)
    PRINT           reduce using rule 49 (expr -> expr GT expr .)
    PROCEDURE       reduce using rule 49 (expr -> expr GT expr .)
    RETURN          reduce using rule 49 (expr -> expr GT expr .)
    VOID            reduce using rule 49 (expr -> expr GT expr .)
    STRING          reduce using rule 49 (expr -> expr GT expr .)
    FLOAT           reduce using rule 49 (expr -> expr GT expr .)
    INT             reduce using rule 49 (expr -> expr GT expr .)
    ID              reduce using rule 49 (expr -> expr GT expr .)
    DEC             reduce using rule 49 (expr -> expr GT expr .)
    INC             reduce using rule 49 (expr -> expr GT expr .)
    NOT             reduce using rule 49 (expr -> expr GT expr .)
    LPAREN          reduce using rule 49 (expr -> expr GT expr .)
    BLTIN           reduce using rule 49 (expr -> expr GT expr .)
    READ            reduce using rule 49 (expr -> expr GT expr .)
    FUNCTION        reduce using rule 49 (expr -> expr GT expr .)
    ARG             reduce using rule 49 (expr -> expr GT expr .)
    FLOATT          reduce using rule 49 (expr -> expr GT expr .)
    INTEGER         reduce using rule 49 (expr -> expr GT expr .)
    COMMA           reduce using rule 49 (expr -> expr GT expr .)
    ELSE            reduce using rule 49 (expr -> expr GT expr .)
    SEMI            reduce using rule 49 (expr -> expr GT expr .)
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 98

    (51) expr -> expr POWER expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 51 (expr -> expr POWER expr .)
    OR              reduce using rule 51 (expr -> expr POWER expr .)
    AND             reduce using rule 51 (expr -> expr POWER expr .)
    NE              reduce using rule 51 (expr -> expr POWER expr .)
    EQ              reduce using rule 51 (expr -> expr POWER expr .)
    LE              reduce using rule 51 (expr -> expr POWER expr .)
    LT              reduce using rule 51 (expr -> expr POWER expr .)
    GE              reduce using rule 51 (expr -> expr POWER expr .)
    GT              reduce using rule 51 (expr -> expr POWER expr .)
    MODULE          reduce using rule 51 (expr -> expr POWER expr .)
    DIVIDE          reduce using rule 51 (expr -> expr POWER expr .)
    TIMES           reduce using rule 51 (expr -> expr POWER expr .)
    MINUS           reduce using rule 51 (expr -> expr POWER expr .)
    PLUS            reduce using rule 51 (expr -> expr POWER expr .)
    RPAREN          reduce using rule 51 (expr -> expr POWER expr .)
    RBRACKET        reduce using rule 51 (expr -> expr POWER expr .)
    LBRACKET        reduce using rule 51 (expr -> expr POWER expr .)
    IF              reduce using rule 51 (expr -> expr POWER expr .)
    FOR             reduce using rule 51 (expr -> expr POWER expr .)
    WHILE           reduce using rule 51 (expr -> expr POWER expr .)
    PRINT           reduce using rule 51 (expr -> expr POWER expr .)
    PROCEDURE       reduce using rule 51 (expr -> expr POWER expr .)
    RETURN          reduce using rule 51 (expr -> expr POWER expr .)
    VOID            reduce using rule 51 (expr -> expr POWER expr .)
    STRING          reduce using rule 51 (expr -> expr POWER expr .)
    FLOAT           reduce using rule 51 (expr -> expr POWER expr .)
    INT             reduce using rule 51 (expr -> expr POWER expr .)
    ID              reduce using rule 51 (expr -> expr POWER expr .)
    DEC             reduce using rule 51 (expr -> expr POWER expr .)
    INC             reduce using rule 51 (expr -> expr POWER expr .)
    NOT             reduce using rule 51 (expr -> expr POWER expr .)
    LPAREN          reduce using rule 51 (expr -> expr POWER expr .)
    BLTIN           reduce using rule 51 (expr -> expr POWER expr .)
    READ            reduce using rule 51 (expr -> expr POWER expr .)
    FUNCTION        reduce using rule 51 (expr -> expr POWER expr .)
    ARG             reduce using rule 51 (expr -> expr POWER expr .)
    FLOATT          reduce using rule 51 (expr -> expr POWER expr .)
    INTEGER         reduce using rule 51 (expr -> expr POWER expr .)
    COMMA           reduce using rule 51 (expr -> expr POWER expr .)
    ELSE            reduce using rule 51 (expr -> expr POWER expr .)
    SEMI            reduce using rule 51 (expr -> expr POWER expr .)
    POWER           shift and go to state 45


state 99

    (52) expr -> expr MODULE expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 52 (expr -> expr MODULE expr .)
    OR              reduce using rule 52 (expr -> expr MODULE expr .)
    AND             reduce using rule 52 (expr -> expr MODULE expr .)
    NE              reduce using rule 52 (expr -> expr MODULE expr .)
    EQ              reduce using rule 52 (expr -> expr MODULE expr .)
    LE              reduce using rule 52 (expr -> expr MODULE expr .)
    LT              reduce using rule 52 (expr -> expr MODULE expr .)
    GE              reduce using rule 52 (expr -> expr MODULE expr .)
    GT              reduce using rule 52 (expr -> expr MODULE expr .)
    MODULE          reduce using rule 52 (expr -> expr MODULE expr .)
    DIVIDE          reduce using rule 52 (expr -> expr MODULE expr .)
    TIMES           reduce using rule 52 (expr -> expr MODULE expr .)
    MINUS           reduce using rule 52 (expr -> expr MODULE expr .)
    PLUS            reduce using rule 52 (expr -> expr MODULE expr .)
    RPAREN          reduce using rule 52 (expr -> expr MODULE expr .)
    RBRACKET        reduce using rule 52 (expr -> expr MODULE expr .)
    LBRACKET        reduce using rule 52 (expr -> expr MODULE expr .)
    IF              reduce using rule 52 (expr -> expr MODULE expr .)
    FOR             reduce using rule 52 (expr -> expr MODULE expr .)
    WHILE           reduce using rule 52 (expr -> expr MODULE expr .)
    PRINT           reduce using rule 52 (expr -> expr MODULE expr .)
    PROCEDURE       reduce using rule 52 (expr -> expr MODULE expr .)
    RETURN          reduce using rule 52 (expr -> expr MODULE expr .)
    VOID            reduce using rule 52 (expr -> expr MODULE expr .)
    STRING          reduce using rule 52 (expr -> expr MODULE expr .)
    FLOAT           reduce using rule 52 (expr -> expr MODULE expr .)
    INT             reduce using rule 52 (expr -> expr MODULE expr .)
    ID              reduce using rule 52 (expr -> expr MODULE expr .)
    DEC             reduce using rule 52 (expr -> expr MODULE expr .)
    INC             reduce using rule 52 (expr -> expr MODULE expr .)
    NOT             reduce using rule 52 (expr -> expr MODULE expr .)
    LPAREN          reduce using rule 52 (expr -> expr MODULE expr .)
    BLTIN           reduce using rule 52 (expr -> expr MODULE expr .)
    READ            reduce using rule 52 (expr -> expr MODULE expr .)
    FUNCTION        reduce using rule 52 (expr -> expr MODULE expr .)
    ARG             reduce using rule 52 (expr -> expr MODULE expr .)
    FLOATT          reduce using rule 52 (expr -> expr MODULE expr .)
    INTEGER         reduce using rule 52 (expr -> expr MODULE expr .)
    COMMA           reduce using rule 52 (expr -> expr MODULE expr .)
    ELSE            reduce using rule 52 (expr -> expr MODULE expr .)
    SEMI            reduce using rule 52 (expr -> expr MODULE expr .)
    POWER           shift and go to state 45


state 100

    (53) expr -> expr DIVIDE expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 53 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 53 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 53 (expr -> expr DIVIDE expr .)
    NE              reduce using rule 53 (expr -> expr DIVIDE expr .)
    EQ              reduce using rule 53 (expr -> expr DIVIDE expr .)
    LE              reduce using rule 53 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 53 (expr -> expr DIVIDE expr .)
    GE              reduce using rule 53 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 53 (expr -> expr DIVIDE expr .)
    MODULE          reduce using rule 53 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 53 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 53 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 53 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 53 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 53 (expr -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 53 (expr -> expr DIVIDE expr .)
    LBRACKET        reduce using rule 53 (expr -> expr DIVIDE expr .)
    IF              reduce using rule 53 (expr -> expr DIVIDE expr .)
    FOR             reduce using rule 53 (expr -> expr DIVIDE expr .)
    WHILE           reduce using rule 53 (expr -> expr DIVIDE expr .)
    PRINT           reduce using rule 53 (expr -> expr DIVIDE expr .)
    PROCEDURE       reduce using rule 53 (expr -> expr DIVIDE expr .)
    RETURN          reduce using rule 53 (expr -> expr DIVIDE expr .)
    VOID            reduce using rule 53 (expr -> expr DIVIDE expr .)
    STRING          reduce using rule 53 (expr -> expr DIVIDE expr .)
    FLOAT           reduce using rule 53 (expr -> expr DIVIDE expr .)
    INT             reduce using rule 53 (expr -> expr DIVIDE expr .)
    ID              reduce using rule 53 (expr -> expr DIVIDE expr .)
    DEC             reduce using rule 53 (expr -> expr DIVIDE expr .)
    INC             reduce using rule 53 (expr -> expr DIVIDE expr .)
    NOT             reduce using rule 53 (expr -> expr DIVIDE expr .)
    LPAREN          reduce using rule 53 (expr -> expr DIVIDE expr .)
    BLTIN           reduce using rule 53 (expr -> expr DIVIDE expr .)
    READ            reduce using rule 53 (expr -> expr DIVIDE expr .)
    FUNCTION        reduce using rule 53 (expr -> expr DIVIDE expr .)
    ARG             reduce using rule 53 (expr -> expr DIVIDE expr .)
    FLOATT          reduce using rule 53 (expr -> expr DIVIDE expr .)
    INTEGER         reduce using rule 53 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 53 (expr -> expr DIVIDE expr .)
    ELSE            reduce using rule 53 (expr -> expr DIVIDE expr .)
    SEMI            reduce using rule 53 (expr -> expr DIVIDE expr .)
    POWER           shift and go to state 45


state 101

    (54) expr -> expr TIMES expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 54 (expr -> expr TIMES expr .)
    OR              reduce using rule 54 (expr -> expr TIMES expr .)
    AND             reduce using rule 54 (expr -> expr TIMES expr .)
    NE              reduce using rule 54 (expr -> expr TIMES expr .)
    EQ              reduce using rule 54 (expr -> expr TIMES expr .)
    LE              reduce using rule 54 (expr -> expr TIMES expr .)
    LT              reduce using rule 54 (expr -> expr TIMES expr .)
    GE              reduce using rule 54 (expr -> expr TIMES expr .)
    GT              reduce using rule 54 (expr -> expr TIMES expr .)
    MODULE          reduce using rule 54 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 54 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 54 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 54 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 54 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 54 (expr -> expr TIMES expr .)
    RBRACKET        reduce using rule 54 (expr -> expr TIMES expr .)
    LBRACKET        reduce using rule 54 (expr -> expr TIMES expr .)
    IF              reduce using rule 54 (expr -> expr TIMES expr .)
    FOR             reduce using rule 54 (expr -> expr TIMES expr .)
    WHILE           reduce using rule 54 (expr -> expr TIMES expr .)
    PRINT           reduce using rule 54 (expr -> expr TIMES expr .)
    PROCEDURE       reduce using rule 54 (expr -> expr TIMES expr .)
    RETURN          reduce using rule 54 (expr -> expr TIMES expr .)
    VOID            reduce using rule 54 (expr -> expr TIMES expr .)
    STRING          reduce using rule 54 (expr -> expr TIMES expr .)
    FLOAT           reduce using rule 54 (expr -> expr TIMES expr .)
    INT             reduce using rule 54 (expr -> expr TIMES expr .)
    ID              reduce using rule 54 (expr -> expr TIMES expr .)
    DEC             reduce using rule 54 (expr -> expr TIMES expr .)
    INC             reduce using rule 54 (expr -> expr TIMES expr .)
    NOT             reduce using rule 54 (expr -> expr TIMES expr .)
    LPAREN          reduce using rule 54 (expr -> expr TIMES expr .)
    BLTIN           reduce using rule 54 (expr -> expr TIMES expr .)
    READ            reduce using rule 54 (expr -> expr TIMES expr .)
    FUNCTION        reduce using rule 54 (expr -> expr TIMES expr .)
    ARG             reduce using rule 54 (expr -> expr TIMES expr .)
    FLOATT          reduce using rule 54 (expr -> expr TIMES expr .)
    INTEGER         reduce using rule 54 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 54 (expr -> expr TIMES expr .)
    ELSE            reduce using rule 54 (expr -> expr TIMES expr .)
    SEMI            reduce using rule 54 (expr -> expr TIMES expr .)
    POWER           shift and go to state 45


state 102

    (55) expr -> expr MINUS expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 55 (expr -> expr MINUS expr .)
    OR              reduce using rule 55 (expr -> expr MINUS expr .)
    AND             reduce using rule 55 (expr -> expr MINUS expr .)
    NE              reduce using rule 55 (expr -> expr MINUS expr .)
    EQ              reduce using rule 55 (expr -> expr MINUS expr .)
    LE              reduce using rule 55 (expr -> expr MINUS expr .)
    LT              reduce using rule 55 (expr -> expr MINUS expr .)
    GE              reduce using rule 55 (expr -> expr MINUS expr .)
    GT              reduce using rule 55 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 55 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 55 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 55 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 55 (expr -> expr MINUS expr .)
    LBRACKET        reduce using rule 55 (expr -> expr MINUS expr .)
    IF              reduce using rule 55 (expr -> expr MINUS expr .)
    FOR             reduce using rule 55 (expr -> expr MINUS expr .)
    WHILE           reduce using rule 55 (expr -> expr MINUS expr .)
    PRINT           reduce using rule 55 (expr -> expr MINUS expr .)
    PROCEDURE       reduce using rule 55 (expr -> expr MINUS expr .)
    RETURN          reduce using rule 55 (expr -> expr MINUS expr .)
    VOID            reduce using rule 55 (expr -> expr MINUS expr .)
    STRING          reduce using rule 55 (expr -> expr MINUS expr .)
    FLOAT           reduce using rule 55 (expr -> expr MINUS expr .)
    INT             reduce using rule 55 (expr -> expr MINUS expr .)
    ID              reduce using rule 55 (expr -> expr MINUS expr .)
    DEC             reduce using rule 55 (expr -> expr MINUS expr .)
    INC             reduce using rule 55 (expr -> expr MINUS expr .)
    NOT             reduce using rule 55 (expr -> expr MINUS expr .)
    LPAREN          reduce using rule 55 (expr -> expr MINUS expr .)
    BLTIN           reduce using rule 55 (expr -> expr MINUS expr .)
    READ            reduce using rule 55 (expr -> expr MINUS expr .)
    FUNCTION        reduce using rule 55 (expr -> expr MINUS expr .)
    ARG             reduce using rule 55 (expr -> expr MINUS expr .)
    FLOATT          reduce using rule 55 (expr -> expr MINUS expr .)
    INTEGER         reduce using rule 55 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 55 (expr -> expr MINUS expr .)
    ELSE            reduce using rule 55 (expr -> expr MINUS expr .)
    SEMI            reduce using rule 55 (expr -> expr MINUS expr .)
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48


state 103

    (56) expr -> expr PLUS expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 56 (expr -> expr PLUS expr .)
    OR              reduce using rule 56 (expr -> expr PLUS expr .)
    AND             reduce using rule 56 (expr -> expr PLUS expr .)
    NE              reduce using rule 56 (expr -> expr PLUS expr .)
    EQ              reduce using rule 56 (expr -> expr PLUS expr .)
    LE              reduce using rule 56 (expr -> expr PLUS expr .)
    LT              reduce using rule 56 (expr -> expr PLUS expr .)
    GE              reduce using rule 56 (expr -> expr PLUS expr .)
    GT              reduce using rule 56 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 56 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 56 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 56 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 56 (expr -> expr PLUS expr .)
    LBRACKET        reduce using rule 56 (expr -> expr PLUS expr .)
    IF              reduce using rule 56 (expr -> expr PLUS expr .)
    FOR             reduce using rule 56 (expr -> expr PLUS expr .)
    WHILE           reduce using rule 56 (expr -> expr PLUS expr .)
    PRINT           reduce using rule 56 (expr -> expr PLUS expr .)
    PROCEDURE       reduce using rule 56 (expr -> expr PLUS expr .)
    RETURN          reduce using rule 56 (expr -> expr PLUS expr .)
    VOID            reduce using rule 56 (expr -> expr PLUS expr .)
    STRING          reduce using rule 56 (expr -> expr PLUS expr .)
    FLOAT           reduce using rule 56 (expr -> expr PLUS expr .)
    INT             reduce using rule 56 (expr -> expr PLUS expr .)
    ID              reduce using rule 56 (expr -> expr PLUS expr .)
    DEC             reduce using rule 56 (expr -> expr PLUS expr .)
    INC             reduce using rule 56 (expr -> expr PLUS expr .)
    NOT             reduce using rule 56 (expr -> expr PLUS expr .)
    LPAREN          reduce using rule 56 (expr -> expr PLUS expr .)
    BLTIN           reduce using rule 56 (expr -> expr PLUS expr .)
    READ            reduce using rule 56 (expr -> expr PLUS expr .)
    FUNCTION        reduce using rule 56 (expr -> expr PLUS expr .)
    ARG             reduce using rule 56 (expr -> expr PLUS expr .)
    FLOATT          reduce using rule 56 (expr -> expr PLUS expr .)
    INTEGER         reduce using rule 56 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 56 (expr -> expr PLUS expr .)
    ELSE            reduce using rule 56 (expr -> expr PLUS expr .)
    SEMI            reduce using rule 56 (expr -> expr PLUS expr .)
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48


state 104

    (59) expr -> ID LPAREN prlist . RPAREN
    (67) prlist -> prlist . COMMA STRINGG
    (68) prlist -> prlist . COMMA expr
    RPAREN          shift and go to state 126
    COMMA           shift and go to state 122


state 105

    (12) assign -> ID MODEQ expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 12 (assign -> ID MODEQ expr .)
    RPAREN          reduce using rule 12 (assign -> ID MODEQ expr .)
    RBRACKET        reduce using rule 12 (assign -> ID MODEQ expr .)
    LBRACKET        reduce using rule 12 (assign -> ID MODEQ expr .)
    IF              reduce using rule 12 (assign -> ID MODEQ expr .)
    FOR             reduce using rule 12 (assign -> ID MODEQ expr .)
    WHILE           reduce using rule 12 (assign -> ID MODEQ expr .)
    PRINT           reduce using rule 12 (assign -> ID MODEQ expr .)
    PROCEDURE       reduce using rule 12 (assign -> ID MODEQ expr .)
    RETURN          reduce using rule 12 (assign -> ID MODEQ expr .)
    VOID            reduce using rule 12 (assign -> ID MODEQ expr .)
    STRING          reduce using rule 12 (assign -> ID MODEQ expr .)
    FLOAT           reduce using rule 12 (assign -> ID MODEQ expr .)
    INT             reduce using rule 12 (assign -> ID MODEQ expr .)
    ID              reduce using rule 12 (assign -> ID MODEQ expr .)
    DEC             reduce using rule 12 (assign -> ID MODEQ expr .)
    INC             reduce using rule 12 (assign -> ID MODEQ expr .)
    NOT             reduce using rule 12 (assign -> ID MODEQ expr .)
    LPAREN          reduce using rule 12 (assign -> ID MODEQ expr .)
    BLTIN           reduce using rule 12 (assign -> ID MODEQ expr .)
    READ            reduce using rule 12 (assign -> ID MODEQ expr .)
    FUNCTION        reduce using rule 12 (assign -> ID MODEQ expr .)
    ARG             reduce using rule 12 (assign -> ID MODEQ expr .)
    FLOATT          reduce using rule 12 (assign -> ID MODEQ expr .)
    INTEGER         reduce using rule 12 (assign -> ID MODEQ expr .)
    COMMA           reduce using rule 12 (assign -> ID MODEQ expr .)
    ELSE            reduce using rule 12 (assign -> ID MODEQ expr .)
    SEMI            reduce using rule 12 (assign -> ID MODEQ expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 106

    (13) assign -> ID DIVEQ expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 13 (assign -> ID DIVEQ expr .)
    RPAREN          reduce using rule 13 (assign -> ID DIVEQ expr .)
    RBRACKET        reduce using rule 13 (assign -> ID DIVEQ expr .)
    LBRACKET        reduce using rule 13 (assign -> ID DIVEQ expr .)
    IF              reduce using rule 13 (assign -> ID DIVEQ expr .)
    FOR             reduce using rule 13 (assign -> ID DIVEQ expr .)
    WHILE           reduce using rule 13 (assign -> ID DIVEQ expr .)
    PRINT           reduce using rule 13 (assign -> ID DIVEQ expr .)
    PROCEDURE       reduce using rule 13 (assign -> ID DIVEQ expr .)
    RETURN          reduce using rule 13 (assign -> ID DIVEQ expr .)
    VOID            reduce using rule 13 (assign -> ID DIVEQ expr .)
    STRING          reduce using rule 13 (assign -> ID DIVEQ expr .)
    FLOAT           reduce using rule 13 (assign -> ID DIVEQ expr .)
    INT             reduce using rule 13 (assign -> ID DIVEQ expr .)
    ID              reduce using rule 13 (assign -> ID DIVEQ expr .)
    DEC             reduce using rule 13 (assign -> ID DIVEQ expr .)
    INC             reduce using rule 13 (assign -> ID DIVEQ expr .)
    NOT             reduce using rule 13 (assign -> ID DIVEQ expr .)
    LPAREN          reduce using rule 13 (assign -> ID DIVEQ expr .)
    BLTIN           reduce using rule 13 (assign -> ID DIVEQ expr .)
    READ            reduce using rule 13 (assign -> ID DIVEQ expr .)
    FUNCTION        reduce using rule 13 (assign -> ID DIVEQ expr .)
    ARG             reduce using rule 13 (assign -> ID DIVEQ expr .)
    FLOATT          reduce using rule 13 (assign -> ID DIVEQ expr .)
    INTEGER         reduce using rule 13 (assign -> ID DIVEQ expr .)
    COMMA           reduce using rule 13 (assign -> ID DIVEQ expr .)
    ELSE            reduce using rule 13 (assign -> ID DIVEQ expr .)
    SEMI            reduce using rule 13 (assign -> ID DIVEQ expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 107

    (14) assign -> ID MULEQ expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 14 (assign -> ID MULEQ expr .)
    RPAREN          reduce using rule 14 (assign -> ID MULEQ expr .)
    RBRACKET        reduce using rule 14 (assign -> ID MULEQ expr .)
    LBRACKET        reduce using rule 14 (assign -> ID MULEQ expr .)
    IF              reduce using rule 14 (assign -> ID MULEQ expr .)
    FOR             reduce using rule 14 (assign -> ID MULEQ expr .)
    WHILE           reduce using rule 14 (assign -> ID MULEQ expr .)
    PRINT           reduce using rule 14 (assign -> ID MULEQ expr .)
    PROCEDURE       reduce using rule 14 (assign -> ID MULEQ expr .)
    RETURN          reduce using rule 14 (assign -> ID MULEQ expr .)
    VOID            reduce using rule 14 (assign -> ID MULEQ expr .)
    STRING          reduce using rule 14 (assign -> ID MULEQ expr .)
    FLOAT           reduce using rule 14 (assign -> ID MULEQ expr .)
    INT             reduce using rule 14 (assign -> ID MULEQ expr .)
    ID              reduce using rule 14 (assign -> ID MULEQ expr .)
    DEC             reduce using rule 14 (assign -> ID MULEQ expr .)
    INC             reduce using rule 14 (assign -> ID MULEQ expr .)
    NOT             reduce using rule 14 (assign -> ID MULEQ expr .)
    LPAREN          reduce using rule 14 (assign -> ID MULEQ expr .)
    BLTIN           reduce using rule 14 (assign -> ID MULEQ expr .)
    READ            reduce using rule 14 (assign -> ID MULEQ expr .)
    FUNCTION        reduce using rule 14 (assign -> ID MULEQ expr .)
    ARG             reduce using rule 14 (assign -> ID MULEQ expr .)
    FLOATT          reduce using rule 14 (assign -> ID MULEQ expr .)
    INTEGER         reduce using rule 14 (assign -> ID MULEQ expr .)
    COMMA           reduce using rule 14 (assign -> ID MULEQ expr .)
    ELSE            reduce using rule 14 (assign -> ID MULEQ expr .)
    SEMI            reduce using rule 14 (assign -> ID MULEQ expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 108

    (15) assign -> ID SUBEQ expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 15 (assign -> ID SUBEQ expr .)
    RPAREN          reduce using rule 15 (assign -> ID SUBEQ expr .)
    RBRACKET        reduce using rule 15 (assign -> ID SUBEQ expr .)
    LBRACKET        reduce using rule 15 (assign -> ID SUBEQ expr .)
    IF              reduce using rule 15 (assign -> ID SUBEQ expr .)
    FOR             reduce using rule 15 (assign -> ID SUBEQ expr .)
    WHILE           reduce using rule 15 (assign -> ID SUBEQ expr .)
    PRINT           reduce using rule 15 (assign -> ID SUBEQ expr .)
    PROCEDURE       reduce using rule 15 (assign -> ID SUBEQ expr .)
    RETURN          reduce using rule 15 (assign -> ID SUBEQ expr .)
    VOID            reduce using rule 15 (assign -> ID SUBEQ expr .)
    STRING          reduce using rule 15 (assign -> ID SUBEQ expr .)
    FLOAT           reduce using rule 15 (assign -> ID SUBEQ expr .)
    INT             reduce using rule 15 (assign -> ID SUBEQ expr .)
    ID              reduce using rule 15 (assign -> ID SUBEQ expr .)
    DEC             reduce using rule 15 (assign -> ID SUBEQ expr .)
    INC             reduce using rule 15 (assign -> ID SUBEQ expr .)
    NOT             reduce using rule 15 (assign -> ID SUBEQ expr .)
    LPAREN          reduce using rule 15 (assign -> ID SUBEQ expr .)
    BLTIN           reduce using rule 15 (assign -> ID SUBEQ expr .)
    READ            reduce using rule 15 (assign -> ID SUBEQ expr .)
    FUNCTION        reduce using rule 15 (assign -> ID SUBEQ expr .)
    ARG             reduce using rule 15 (assign -> ID SUBEQ expr .)
    FLOATT          reduce using rule 15 (assign -> ID SUBEQ expr .)
    INTEGER         reduce using rule 15 (assign -> ID SUBEQ expr .)
    COMMA           reduce using rule 15 (assign -> ID SUBEQ expr .)
    ELSE            reduce using rule 15 (assign -> ID SUBEQ expr .)
    SEMI            reduce using rule 15 (assign -> ID SUBEQ expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 109

    (16) assign -> ID ADDEQ expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 16 (assign -> ID ADDEQ expr .)
    RPAREN          reduce using rule 16 (assign -> ID ADDEQ expr .)
    RBRACKET        reduce using rule 16 (assign -> ID ADDEQ expr .)
    LBRACKET        reduce using rule 16 (assign -> ID ADDEQ expr .)
    IF              reduce using rule 16 (assign -> ID ADDEQ expr .)
    FOR             reduce using rule 16 (assign -> ID ADDEQ expr .)
    WHILE           reduce using rule 16 (assign -> ID ADDEQ expr .)
    PRINT           reduce using rule 16 (assign -> ID ADDEQ expr .)
    PROCEDURE       reduce using rule 16 (assign -> ID ADDEQ expr .)
    RETURN          reduce using rule 16 (assign -> ID ADDEQ expr .)
    VOID            reduce using rule 16 (assign -> ID ADDEQ expr .)
    STRING          reduce using rule 16 (assign -> ID ADDEQ expr .)
    FLOAT           reduce using rule 16 (assign -> ID ADDEQ expr .)
    INT             reduce using rule 16 (assign -> ID ADDEQ expr .)
    ID              reduce using rule 16 (assign -> ID ADDEQ expr .)
    DEC             reduce using rule 16 (assign -> ID ADDEQ expr .)
    INC             reduce using rule 16 (assign -> ID ADDEQ expr .)
    NOT             reduce using rule 16 (assign -> ID ADDEQ expr .)
    LPAREN          reduce using rule 16 (assign -> ID ADDEQ expr .)
    BLTIN           reduce using rule 16 (assign -> ID ADDEQ expr .)
    READ            reduce using rule 16 (assign -> ID ADDEQ expr .)
    FUNCTION        reduce using rule 16 (assign -> ID ADDEQ expr .)
    ARG             reduce using rule 16 (assign -> ID ADDEQ expr .)
    FLOATT          reduce using rule 16 (assign -> ID ADDEQ expr .)
    INTEGER         reduce using rule 16 (assign -> ID ADDEQ expr .)
    COMMA           reduce using rule 16 (assign -> ID ADDEQ expr .)
    ELSE            reduce using rule 16 (assign -> ID ADDEQ expr .)
    SEMI            reduce using rule 16 (assign -> ID ADDEQ expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 110

    (17) assign -> ID ASSIGN expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    NEWLINE         reduce using rule 17 (assign -> ID ASSIGN expr .)
    RPAREN          reduce using rule 17 (assign -> ID ASSIGN expr .)
    RBRACKET        reduce using rule 17 (assign -> ID ASSIGN expr .)
    LBRACKET        reduce using rule 17 (assign -> ID ASSIGN expr .)
    IF              reduce using rule 17 (assign -> ID ASSIGN expr .)
    FOR             reduce using rule 17 (assign -> ID ASSIGN expr .)
    WHILE           reduce using rule 17 (assign -> ID ASSIGN expr .)
    PRINT           reduce using rule 17 (assign -> ID ASSIGN expr .)
    PROCEDURE       reduce using rule 17 (assign -> ID ASSIGN expr .)
    RETURN          reduce using rule 17 (assign -> ID ASSIGN expr .)
    VOID            reduce using rule 17 (assign -> ID ASSIGN expr .)
    STRING          reduce using rule 17 (assign -> ID ASSIGN expr .)
    FLOAT           reduce using rule 17 (assign -> ID ASSIGN expr .)
    INT             reduce using rule 17 (assign -> ID ASSIGN expr .)
    ID              reduce using rule 17 (assign -> ID ASSIGN expr .)
    DEC             reduce using rule 17 (assign -> ID ASSIGN expr .)
    INC             reduce using rule 17 (assign -> ID ASSIGN expr .)
    NOT             reduce using rule 17 (assign -> ID ASSIGN expr .)
    LPAREN          reduce using rule 17 (assign -> ID ASSIGN expr .)
    BLTIN           reduce using rule 17 (assign -> ID ASSIGN expr .)
    READ            reduce using rule 17 (assign -> ID ASSIGN expr .)
    FUNCTION        reduce using rule 17 (assign -> ID ASSIGN expr .)
    ARG             reduce using rule 17 (assign -> ID ASSIGN expr .)
    FLOATT          reduce using rule 17 (assign -> ID ASSIGN expr .)
    INTEGER         reduce using rule 17 (assign -> ID ASSIGN expr .)
    COMMA           reduce using rule 17 (assign -> ID ASSIGN expr .)
    ELSE            reduce using rule 17 (assign -> ID ASSIGN expr .)
    SEMI            reduce using rule 17 (assign -> ID ASSIGN expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 111

    (57) expr -> LPAREN expr RPAREN .
    NEWLINE         reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    POWER           reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    MODULE          reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    IF              reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    FOR             reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    WHILE           reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    PRINT           reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    PROCEDURE       reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    VOID            reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    STRING          reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    FLOAT           reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    INT             reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    ID              reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    DEC             reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    INC             reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    NOT             reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    BLTIN           reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    READ            reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    FUNCTION        reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    ARG             reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    FLOATT          reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    INTEGER         reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    ELSE            reduce using rule 57 (expr -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 57 (expr -> LPAREN expr RPAREN .)


state 112

    (58) expr -> BLTIN LPAREN expr . RPAREN
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    RPAREN          shift and go to state 127
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 113

    (60) expr -> READ LPAREN ID . RPAREN
    RPAREN          shift and go to state 128


state 114

    (61) expr -> FUNCTION begin LPAREN . arglist RPAREN
    (81) arglist -> . arglist COMMA expr
    (82) arglist -> . expr
    (83) arglist -> . empty
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (84) empty -> .
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)

    arglist                        shift and go to state 129
    expr                           shift and go to state 130
    empty                          shift and go to state 131
    assign                         shift and go to state 66

state 115

    (20) stmt -> LBRACKET stmtlist RBRACKET .
    NEWLINE         reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    RBRACKET        reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    LBRACKET        reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    IF              reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    FOR             reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    WHILE           reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    PRINT           reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    PROCEDURE       reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    RETURN          reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    VOID            reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    STRING          reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    FLOAT           reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    INT             reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    ID              reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    DEC             reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    INC             reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    NOT             reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    MINUS           reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    LPAREN          reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    BLTIN           reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    READ            reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    FUNCTION        reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    ARG             reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    FLOATT          reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    INTEGER         reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)
    ELSE            reduce using rule 20 (stmt -> LBRACKET stmtlist RBRACKET .)


state 116

    (33) stmtlist -> stmtlist stmt .
    RBRACKET        reduce using rule 33 (stmtlist -> stmtlist stmt .)
    NEWLINE         reduce using rule 33 (stmtlist -> stmtlist stmt .)
    LBRACKET        reduce using rule 33 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 33 (stmtlist -> stmtlist stmt .)
    FOR             reduce using rule 33 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 33 (stmtlist -> stmtlist stmt .)
    PRINT           reduce using rule 33 (stmtlist -> stmtlist stmt .)
    PROCEDURE       reduce using rule 33 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 33 (stmtlist -> stmtlist stmt .)
    VOID            reduce using rule 33 (stmtlist -> stmtlist stmt .)
    STRING          reduce using rule 33 (stmtlist -> stmtlist stmt .)
    FLOAT           reduce using rule 33 (stmtlist -> stmtlist stmt .)
    INT             reduce using rule 33 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 33 (stmtlist -> stmtlist stmt .)
    DEC             reduce using rule 33 (stmtlist -> stmtlist stmt .)
    INC             reduce using rule 33 (stmtlist -> stmtlist stmt .)
    NOT             reduce using rule 33 (stmtlist -> stmtlist stmt .)
    MINUS           reduce using rule 33 (stmtlist -> stmtlist stmt .)
    LPAREN          reduce using rule 33 (stmtlist -> stmtlist stmt .)
    BLTIN           reduce using rule 33 (stmtlist -> stmtlist stmt .)
    READ            reduce using rule 33 (stmtlist -> stmtlist stmt .)
    FUNCTION        reduce using rule 33 (stmtlist -> stmtlist stmt .)
    ARG             reduce using rule 33 (stmtlist -> stmtlist stmt .)
    FLOATT          reduce using rule 33 (stmtlist -> stmtlist stmt .)
    INTEGER         reduce using rule 33 (stmtlist -> stmtlist stmt .)


state 117

    (34) stmtlist -> stmtlist NEWLINE .
    RBRACKET        reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    NEWLINE         reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    LBRACKET        reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    IF              reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    FOR             reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    WHILE           reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    PRINT           reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    PROCEDURE       reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    RETURN          reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    VOID            reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    STRING          reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    FLOAT           reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    INT             reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    ID              reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    DEC             reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    INC             reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    NOT             reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    MINUS           reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    LPAREN          reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    BLTIN           reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    READ            reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    FUNCTION        reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    ARG             reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    FLOATT          reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)
    INTEGER         reduce using rule 34 (stmtlist -> stmtlist NEWLINE .)


state 118

    (21) stmt -> IF LPAREN cond . RPAREN stmt end ELSE stmt end
    (22) stmt -> IF LPAREN cond . RPAREN stmt end
    RPAREN          shift and go to state 132


state 119

    (30) cond -> expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    RPAREN          reduce using rule 30 (cond -> expr .)
    SEMI            reduce using rule 30 (cond -> expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 120

    (23) stmt -> FOR LPAREN cond . SEMI cond SEMI cond RPAREN stmt end
    SEMI            shift and go to state 133


state 121

    (24) stmt -> WHILE LPAREN cond . RPAREN stmt end
    RPAREN          shift and go to state 134


state 122

    (67) prlist -> prlist COMMA . STRINGG
    (68) prlist -> prlist COMMA . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    STRINGG         shift and go to state 135
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 136
    assign                         shift and go to state 66

state 123

    (26) stmt -> PROCEDURE begin LPAREN . arglist RPAREN
    (81) arglist -> . arglist COMMA expr
    (82) arglist -> . expr
    (83) arglist -> . empty
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (84) empty -> .
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)

    arglist                        shift and go to state 137
    expr                           shift and go to state 130
    empty                          shift and go to state 131
    assign                         shift and go to state 66

state 124

    (18) defn -> PROC procname LPAREN . formalopt RPAREN stmt
    (76) formalopt -> . formalsss
    (77) formalopt -> . formals
    (74) formalsss -> . type ID COMMA formalsss
    (75) formalsss -> . type ID
    (71) formals -> . ID COMMA formals
    (72) formals -> . ID
    (73) formals -> . empty
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    (84) empty -> .
    ID              shift and go to state 142
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34
    RPAREN          reduce using rule 84 (empty -> .)

    formalopt                      shift and go to state 138
    formalsss                      shift and go to state 139
    formals                        shift and go to state 140
    type                           shift and go to state 141
    empty                          shift and go to state 143

state 125

    (19) defn -> FUNC procname LPAREN . formalopt RPAREN type stmt
    (76) formalopt -> . formalsss
    (77) formalopt -> . formals
    (74) formalsss -> . type ID COMMA formalsss
    (75) formalsss -> . type ID
    (71) formals -> . ID COMMA formals
    (72) formals -> . ID
    (73) formals -> . empty
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    (84) empty -> .
    ID              shift and go to state 142
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34
    RPAREN          reduce using rule 84 (empty -> .)

    formalopt                      shift and go to state 144
    type                           shift and go to state 141
    formalsss                      shift and go to state 139
    formals                        shift and go to state 140
    empty                          shift and go to state 143

state 126

    (59) expr -> ID LPAREN prlist RPAREN .
    NEWLINE         reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    OR              reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    AND             reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    NE              reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    EQ              reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    LE              reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    LT              reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    GE              reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    GT              reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    POWER           reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    MODULE          reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    DIVIDE          reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    TIMES           reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    MINUS           reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    PLUS            reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    RPAREN          reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    RBRACKET        reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    LBRACKET        reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    IF              reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    FOR             reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    WHILE           reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    PRINT           reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    PROCEDURE       reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    RETURN          reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    VOID            reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    STRING          reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    FLOAT           reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    INT             reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    ID              reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    DEC             reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    INC             reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    NOT             reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    LPAREN          reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    BLTIN           reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    READ            reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    FUNCTION        reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    ARG             reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    FLOATT          reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    INTEGER         reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    COMMA           reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    ELSE            reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)
    SEMI            reduce using rule 59 (expr -> ID LPAREN prlist RPAREN .)


state 127

    (58) expr -> BLTIN LPAREN expr RPAREN .
    NEWLINE         reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    OR              reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    AND             reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    NE              reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    EQ              reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    LE              reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    LT              reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    GE              reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    GT              reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    POWER           reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    MODULE          reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    TIMES           reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    MINUS           reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    PLUS            reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    RPAREN          reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    IF              reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    FOR             reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    WHILE           reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    PRINT           reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    PROCEDURE       reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    RETURN          reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    VOID            reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    STRING          reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    FLOAT           reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    INT             reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    ID              reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    DEC             reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    INC             reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    NOT             reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    LPAREN          reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    BLTIN           reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    READ            reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    FUNCTION        reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    ARG             reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    FLOATT          reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    INTEGER         reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    COMMA           reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    ELSE            reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)
    SEMI            reduce using rule 58 (expr -> BLTIN LPAREN expr RPAREN .)


state 128

    (60) expr -> READ LPAREN ID RPAREN .
    NEWLINE         reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    OR              reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    AND             reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    NE              reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    EQ              reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    LE              reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    LT              reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    GE              reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    GT              reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    POWER           reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    MODULE          reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    DIVIDE          reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    TIMES           reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    MINUS           reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    PLUS            reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    RPAREN          reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    RBRACKET        reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    LBRACKET        reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    IF              reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    FOR             reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    WHILE           reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    PRINT           reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    PROCEDURE       reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    RETURN          reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    VOID            reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    STRING          reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    FLOAT           reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    INT             reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    ID              reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    DEC             reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    INC             reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    NOT             reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    LPAREN          reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    BLTIN           reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    READ            reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    FUNCTION        reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    ARG             reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    FLOATT          reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    INTEGER         reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    COMMA           reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    ELSE            reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)
    SEMI            reduce using rule 60 (expr -> READ LPAREN ID RPAREN .)


state 129

    (61) expr -> FUNCTION begin LPAREN arglist . RPAREN
    (81) arglist -> arglist . COMMA expr
    RPAREN          shift and go to state 145
    COMMA           shift and go to state 146


state 130

    (82) arglist -> expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    RPAREN          reduce using rule 82 (arglist -> expr .)
    COMMA           reduce using rule 82 (arglist -> expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 131

    (83) arglist -> empty .
    RPAREN          reduce using rule 83 (arglist -> empty .)
    COMMA           reduce using rule 83 (arglist -> empty .)


state 132

    (21) stmt -> IF LPAREN cond RPAREN . stmt end ELSE stmt end
    (22) stmt -> IF LPAREN cond RPAREN . stmt end
    (20) stmt -> . LBRACKET stmtlist RBRACKET
    (21) stmt -> . IF LPAREN cond RPAREN stmt end ELSE stmt end
    (22) stmt -> . IF LPAREN cond RPAREN stmt end
    (23) stmt -> . FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end
    (24) stmt -> . WHILE LPAREN cond RPAREN stmt end
    (25) stmt -> . PRINT prlist
    (26) stmt -> . PROCEDURE begin LPAREN arglist RPAREN
    (27) stmt -> . RETURN expr
    (28) stmt -> . type ID
    (29) stmt -> . expr
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    LBRACKET        shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    WHILE           shift and go to state 24
    PRINT           shift and go to state 25
    PROCEDURE       shift and go to state 26
    RETURN          shift and go to state 27
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    stmt                           shift and go to state 147
    expr                           shift and go to state 75
    type                           shift and go to state 28
    assign                         shift and go to state 66

state 133

    (23) stmt -> FOR LPAREN cond SEMI . cond SEMI cond RPAREN stmt end
    (30) cond -> . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    cond                           shift and go to state 148
    expr                           shift and go to state 119
    assign                         shift and go to state 66

state 134

    (24) stmt -> WHILE LPAREN cond RPAREN . stmt end
    (20) stmt -> . LBRACKET stmtlist RBRACKET
    (21) stmt -> . IF LPAREN cond RPAREN stmt end ELSE stmt end
    (22) stmt -> . IF LPAREN cond RPAREN stmt end
    (23) stmt -> . FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end
    (24) stmt -> . WHILE LPAREN cond RPAREN stmt end
    (25) stmt -> . PRINT prlist
    (26) stmt -> . PROCEDURE begin LPAREN arglist RPAREN
    (27) stmt -> . RETURN expr
    (28) stmt -> . type ID
    (29) stmt -> . expr
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    LBRACKET        shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    WHILE           shift and go to state 24
    PRINT           shift and go to state 25
    PROCEDURE       shift and go to state 26
    RETURN          shift and go to state 27
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    stmt                           shift and go to state 149
    expr                           shift and go to state 75
    type                           shift and go to state 28
    assign                         shift and go to state 66

state 135

    (67) prlist -> prlist COMMA STRINGG .
    COMMA           reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    NEWLINE         reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    RBRACKET        reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    LBRACKET        reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    IF              reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    FOR             reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    WHILE           reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    PRINT           reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    PROCEDURE       reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    RETURN          reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    VOID            reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    STRING          reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    FLOAT           reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    INT             reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    ID              reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    DEC             reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    INC             reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    NOT             reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    MINUS           reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    LPAREN          reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    BLTIN           reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    READ            reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    FUNCTION        reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    ARG             reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    FLOATT          reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    INTEGER         reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    ELSE            reduce using rule 67 (prlist -> prlist COMMA STRINGG .)
    RPAREN          reduce using rule 67 (prlist -> prlist COMMA STRINGG .)


state 136

    (68) prlist -> prlist COMMA expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 68 (prlist -> prlist COMMA expr .)
    NEWLINE         reduce using rule 68 (prlist -> prlist COMMA expr .)
    RBRACKET        reduce using rule 68 (prlist -> prlist COMMA expr .)
    LBRACKET        reduce using rule 68 (prlist -> prlist COMMA expr .)
    IF              reduce using rule 68 (prlist -> prlist COMMA expr .)
    FOR             reduce using rule 68 (prlist -> prlist COMMA expr .)
    WHILE           reduce using rule 68 (prlist -> prlist COMMA expr .)
    PRINT           reduce using rule 68 (prlist -> prlist COMMA expr .)
    PROCEDURE       reduce using rule 68 (prlist -> prlist COMMA expr .)
    RETURN          reduce using rule 68 (prlist -> prlist COMMA expr .)
    VOID            reduce using rule 68 (prlist -> prlist COMMA expr .)
    STRING          reduce using rule 68 (prlist -> prlist COMMA expr .)
    FLOAT           reduce using rule 68 (prlist -> prlist COMMA expr .)
    INT             reduce using rule 68 (prlist -> prlist COMMA expr .)
    ID              reduce using rule 68 (prlist -> prlist COMMA expr .)
    DEC             reduce using rule 68 (prlist -> prlist COMMA expr .)
    INC             reduce using rule 68 (prlist -> prlist COMMA expr .)
    NOT             reduce using rule 68 (prlist -> prlist COMMA expr .)
    LPAREN          reduce using rule 68 (prlist -> prlist COMMA expr .)
    BLTIN           reduce using rule 68 (prlist -> prlist COMMA expr .)
    READ            reduce using rule 68 (prlist -> prlist COMMA expr .)
    FUNCTION        reduce using rule 68 (prlist -> prlist COMMA expr .)
    ARG             reduce using rule 68 (prlist -> prlist COMMA expr .)
    FLOATT          reduce using rule 68 (prlist -> prlist COMMA expr .)
    INTEGER         reduce using rule 68 (prlist -> prlist COMMA expr .)
    ELSE            reduce using rule 68 (prlist -> prlist COMMA expr .)
    RPAREN          reduce using rule 68 (prlist -> prlist COMMA expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 137

    (26) stmt -> PROCEDURE begin LPAREN arglist . RPAREN
    (81) arglist -> arglist . COMMA expr
    RPAREN          shift and go to state 150
    COMMA           shift and go to state 146


state 138

    (18) defn -> PROC procname LPAREN formalopt . RPAREN stmt
    RPAREN          shift and go to state 151


state 139

    (76) formalopt -> formalsss .
    RPAREN          reduce using rule 76 (formalopt -> formalsss .)


state 140

    (77) formalopt -> formals .
    RPAREN          reduce using rule 77 (formalopt -> formals .)


state 141

    (74) formalsss -> type . ID COMMA formalsss
    (75) formalsss -> type . ID
    ID              shift and go to state 152


state 142

    (71) formals -> ID . COMMA formals
    (72) formals -> ID .
    COMMA           shift and go to state 153
    RPAREN          reduce using rule 72 (formals -> ID .)


state 143

    (73) formals -> empty .
    RPAREN          reduce using rule 73 (formals -> empty .)


state 144

    (19) defn -> FUNC procname LPAREN formalopt . RPAREN type stmt
    RPAREN          shift and go to state 154


state 145

    (61) expr -> FUNCTION begin LPAREN arglist RPAREN .
    NEWLINE         reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    OR              reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    AND             reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    NE              reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    EQ              reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    LE              reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    LT              reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    GE              reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    GT              reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    POWER           reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    MODULE          reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    DIVIDE          reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    TIMES           reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    MINUS           reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    PLUS            reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    RPAREN          reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    RBRACKET        reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    LBRACKET        reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    IF              reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    FOR             reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    WHILE           reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    PRINT           reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    PROCEDURE       reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    RETURN          reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    VOID            reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    STRING          reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    FLOAT           reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    INT             reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    ID              reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    DEC             reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    INC             reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    NOT             reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    LPAREN          reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    BLTIN           reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    READ            reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    FUNCTION        reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    ARG             reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    FLOATT          reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    INTEGER         reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    COMMA           reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    ELSE            reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)
    SEMI            reduce using rule 61 (expr -> FUNCTION begin LPAREN arglist RPAREN .)


state 146

    (81) arglist -> arglist COMMA . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 155
    assign                         shift and go to state 66

state 147

    (21) stmt -> IF LPAREN cond RPAREN stmt . end ELSE stmt end
    (22) stmt -> IF LPAREN cond RPAREN stmt . end
    (32) end -> .
    ELSE            reduce using rule 32 (end -> .)
    NEWLINE         reduce using rule 32 (end -> .)
    RBRACKET        reduce using rule 32 (end -> .)
    LBRACKET        reduce using rule 32 (end -> .)
    IF              reduce using rule 32 (end -> .)
    FOR             reduce using rule 32 (end -> .)
    WHILE           reduce using rule 32 (end -> .)
    PRINT           reduce using rule 32 (end -> .)
    PROCEDURE       reduce using rule 32 (end -> .)
    RETURN          reduce using rule 32 (end -> .)
    VOID            reduce using rule 32 (end -> .)
    STRING          reduce using rule 32 (end -> .)
    FLOAT           reduce using rule 32 (end -> .)
    INT             reduce using rule 32 (end -> .)
    ID              reduce using rule 32 (end -> .)
    DEC             reduce using rule 32 (end -> .)
    INC             reduce using rule 32 (end -> .)
    NOT             reduce using rule 32 (end -> .)
    MINUS           reduce using rule 32 (end -> .)
    LPAREN          reduce using rule 32 (end -> .)
    BLTIN           reduce using rule 32 (end -> .)
    READ            reduce using rule 32 (end -> .)
    FUNCTION        reduce using rule 32 (end -> .)
    ARG             reduce using rule 32 (end -> .)
    FLOATT          reduce using rule 32 (end -> .)
    INTEGER         reduce using rule 32 (end -> .)

    end                            shift and go to state 156

state 148

    (23) stmt -> FOR LPAREN cond SEMI cond . SEMI cond RPAREN stmt end
    SEMI            shift and go to state 157


state 149

    (24) stmt -> WHILE LPAREN cond RPAREN stmt . end
    (32) end -> .
    NEWLINE         reduce using rule 32 (end -> .)
    RBRACKET        reduce using rule 32 (end -> .)
    LBRACKET        reduce using rule 32 (end -> .)
    IF              reduce using rule 32 (end -> .)
    FOR             reduce using rule 32 (end -> .)
    WHILE           reduce using rule 32 (end -> .)
    PRINT           reduce using rule 32 (end -> .)
    PROCEDURE       reduce using rule 32 (end -> .)
    RETURN          reduce using rule 32 (end -> .)
    VOID            reduce using rule 32 (end -> .)
    STRING          reduce using rule 32 (end -> .)
    FLOAT           reduce using rule 32 (end -> .)
    INT             reduce using rule 32 (end -> .)
    ID              reduce using rule 32 (end -> .)
    DEC             reduce using rule 32 (end -> .)
    INC             reduce using rule 32 (end -> .)
    NOT             reduce using rule 32 (end -> .)
    MINUS           reduce using rule 32 (end -> .)
    LPAREN          reduce using rule 32 (end -> .)
    BLTIN           reduce using rule 32 (end -> .)
    READ            reduce using rule 32 (end -> .)
    FUNCTION        reduce using rule 32 (end -> .)
    ARG             reduce using rule 32 (end -> .)
    FLOATT          reduce using rule 32 (end -> .)
    INTEGER         reduce using rule 32 (end -> .)
    ELSE            reduce using rule 32 (end -> .)

    end                            shift and go to state 158

state 150

    (26) stmt -> PROCEDURE begin LPAREN arglist RPAREN .
    NEWLINE         reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    RBRACKET        reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    LBRACKET        reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    IF              reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    FOR             reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    WHILE           reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    PRINT           reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    PROCEDURE       reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    RETURN          reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    VOID            reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    STRING          reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    FLOAT           reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    INT             reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    ID              reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    DEC             reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    INC             reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    NOT             reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    MINUS           reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    LPAREN          reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    BLTIN           reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    READ            reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    FUNCTION        reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    ARG             reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    FLOATT          reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    INTEGER         reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)
    ELSE            reduce using rule 26 (stmt -> PROCEDURE begin LPAREN arglist RPAREN .)


state 151

    (18) defn -> PROC procname LPAREN formalopt RPAREN . stmt
    (20) stmt -> . LBRACKET stmtlist RBRACKET
    (21) stmt -> . IF LPAREN cond RPAREN stmt end ELSE stmt end
    (22) stmt -> . IF LPAREN cond RPAREN stmt end
    (23) stmt -> . FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end
    (24) stmt -> . WHILE LPAREN cond RPAREN stmt end
    (25) stmt -> . PRINT prlist
    (26) stmt -> . PROCEDURE begin LPAREN arglist RPAREN
    (27) stmt -> . RETURN expr
    (28) stmt -> . type ID
    (29) stmt -> . expr
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    LBRACKET        shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    WHILE           shift and go to state 24
    PRINT           shift and go to state 25
    PROCEDURE       shift and go to state 26
    RETURN          shift and go to state 27
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    stmt                           shift and go to state 159
    expr                           shift and go to state 75
    type                           shift and go to state 28
    assign                         shift and go to state 66

state 152

    (74) formalsss -> type ID . COMMA formalsss
    (75) formalsss -> type ID .
    COMMA           shift and go to state 160
    RPAREN          reduce using rule 75 (formalsss -> type ID .)


state 153

    (71) formals -> ID COMMA . formals
    (71) formals -> . ID COMMA formals
    (72) formals -> . ID
    (73) formals -> . empty
    (84) empty -> .
    ID              shift and go to state 142
    RPAREN          reduce using rule 84 (empty -> .)

    formals                        shift and go to state 161
    empty                          shift and go to state 143

state 154

    (19) defn -> FUNC procname LPAREN formalopt RPAREN . type stmt
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34

    type                           shift and go to state 162

state 155

    (81) arglist -> arglist COMMA expr .
    (42) expr -> expr . OR expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . NE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . LE expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GE expr
    (49) expr -> expr . GT expr
    (51) expr -> expr . POWER expr
    (52) expr -> expr . MODULE expr
    (53) expr -> expr . DIVIDE expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . MINUS expr
    (56) expr -> expr . PLUS expr
    RPAREN          reduce using rule 81 (arglist -> arglist COMMA expr .)
    COMMA           reduce using rule 81 (arglist -> arglist COMMA expr .)
    OR              shift and go to state 37
    AND             shift and go to state 38
    NE              shift and go to state 39
    EQ              shift and go to state 40
    LE              shift and go to state 41
    LT              shift and go to state 42
    GE              shift and go to state 43
    GT              shift and go to state 44
    POWER           shift and go to state 45
    MODULE          shift and go to state 46
    DIVIDE          shift and go to state 47
    TIMES           shift and go to state 48
    MINUS           shift and go to state 49
    PLUS            shift and go to state 50


state 156

    (21) stmt -> IF LPAREN cond RPAREN stmt end . ELSE stmt end
    (22) stmt -> IF LPAREN cond RPAREN stmt end .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 163
    NEWLINE         reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    RBRACKET        reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    LBRACKET        reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    IF              reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    FOR             reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    WHILE           reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    PRINT           reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    PROCEDURE       reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    RETURN          reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    VOID            reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    STRING          reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    FLOAT           reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    INT             reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    ID              reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    DEC             reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    INC             reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    NOT             reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    MINUS           reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    LPAREN          reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    BLTIN           reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    READ            reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    FUNCTION        reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    ARG             reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    FLOATT          reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)
    INTEGER         reduce using rule 22 (stmt -> IF LPAREN cond RPAREN stmt end .)


state 157

    (23) stmt -> FOR LPAREN cond SEMI cond SEMI . cond RPAREN stmt end
    (30) cond -> . expr
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    cond                           shift and go to state 164
    expr                           shift and go to state 119
    assign                         shift and go to state 66

state 158

    (24) stmt -> WHILE LPAREN cond RPAREN stmt end .
    NEWLINE         reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    RBRACKET        reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    LBRACKET        reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    IF              reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    FOR             reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    WHILE           reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    PRINT           reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    PROCEDURE       reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    RETURN          reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    VOID            reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    STRING          reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    FLOAT           reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    INT             reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    ID              reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    DEC             reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    INC             reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    NOT             reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    MINUS           reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    LPAREN          reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    BLTIN           reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    READ            reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    FUNCTION        reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    ARG             reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    FLOATT          reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    INTEGER         reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)
    ELSE            reduce using rule 24 (stmt -> WHILE LPAREN cond RPAREN stmt end .)


state 159

    (18) defn -> PROC procname LPAREN formalopt RPAREN stmt .
    NEWLINE         reduce using rule 18 (defn -> PROC procname LPAREN formalopt RPAREN stmt .)


state 160

    (74) formalsss -> type ID COMMA . formalsss
    (74) formalsss -> . type ID COMMA formalsss
    (75) formalsss -> . type ID
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34

    type                           shift and go to state 141
    formalsss                      shift and go to state 165

state 161

    (71) formals -> ID COMMA formals .
    RPAREN          reduce using rule 71 (formals -> ID COMMA formals .)


state 162

    (19) defn -> FUNC procname LPAREN formalopt RPAREN type . stmt
    (20) stmt -> . LBRACKET stmtlist RBRACKET
    (21) stmt -> . IF LPAREN cond RPAREN stmt end ELSE stmt end
    (22) stmt -> . IF LPAREN cond RPAREN stmt end
    (23) stmt -> . FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end
    (24) stmt -> . WHILE LPAREN cond RPAREN stmt end
    (25) stmt -> . PRINT prlist
    (26) stmt -> . PROCEDURE begin LPAREN arglist RPAREN
    (27) stmt -> . RETURN expr
    (28) stmt -> . type ID
    (29) stmt -> . expr
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    LBRACKET        shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    WHILE           shift and go to state 24
    PRINT           shift and go to state 25
    PROCEDURE       shift and go to state 26
    RETURN          shift and go to state 27
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    type                           shift and go to state 28
    stmt                           shift and go to state 166
    expr                           shift and go to state 75
    assign                         shift and go to state 66

state 163

    (21) stmt -> IF LPAREN cond RPAREN stmt end ELSE . stmt end
    (20) stmt -> . LBRACKET stmtlist RBRACKET
    (21) stmt -> . IF LPAREN cond RPAREN stmt end ELSE stmt end
    (22) stmt -> . IF LPAREN cond RPAREN stmt end
    (23) stmt -> . FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end
    (24) stmt -> . WHILE LPAREN cond RPAREN stmt end
    (25) stmt -> . PRINT prlist
    (26) stmt -> . PROCEDURE begin LPAREN arglist RPAREN
    (27) stmt -> . RETURN expr
    (28) stmt -> . type ID
    (29) stmt -> . expr
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    LBRACKET        shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    WHILE           shift and go to state 24
    PRINT           shift and go to state 25
    PROCEDURE       shift and go to state 26
    RETURN          shift and go to state 27
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    stmt                           shift and go to state 167
    expr                           shift and go to state 75
    type                           shift and go to state 28
    assign                         shift and go to state 66

state 164

    (23) stmt -> FOR LPAREN cond SEMI cond SEMI cond . RPAREN stmt end
    RPAREN          shift and go to state 168


state 165

    (74) formalsss -> type ID COMMA formalsss .
    RPAREN          reduce using rule 74 (formalsss -> type ID COMMA formalsss .)


state 166

    (19) defn -> FUNC procname LPAREN formalopt RPAREN type stmt .
    NEWLINE         reduce using rule 19 (defn -> FUNC procname LPAREN formalopt RPAREN type stmt .)


state 167

    (21) stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt . end
    (32) end -> .
    NEWLINE         reduce using rule 32 (end -> .)
    RBRACKET        reduce using rule 32 (end -> .)
    LBRACKET        reduce using rule 32 (end -> .)
    IF              reduce using rule 32 (end -> .)
    FOR             reduce using rule 32 (end -> .)
    WHILE           reduce using rule 32 (end -> .)
    PRINT           reduce using rule 32 (end -> .)
    PROCEDURE       reduce using rule 32 (end -> .)
    RETURN          reduce using rule 32 (end -> .)
    VOID            reduce using rule 32 (end -> .)
    STRING          reduce using rule 32 (end -> .)
    FLOAT           reduce using rule 32 (end -> .)
    INT             reduce using rule 32 (end -> .)
    ID              reduce using rule 32 (end -> .)
    DEC             reduce using rule 32 (end -> .)
    INC             reduce using rule 32 (end -> .)
    NOT             reduce using rule 32 (end -> .)
    MINUS           reduce using rule 32 (end -> .)
    LPAREN          reduce using rule 32 (end -> .)
    BLTIN           reduce using rule 32 (end -> .)
    READ            reduce using rule 32 (end -> .)
    FUNCTION        reduce using rule 32 (end -> .)
    ARG             reduce using rule 32 (end -> .)
    FLOATT          reduce using rule 32 (end -> .)
    INTEGER         reduce using rule 32 (end -> .)
    ELSE            reduce using rule 32 (end -> .)

    end                            shift and go to state 169

state 168

    (23) stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN . stmt end
    (20) stmt -> . LBRACKET stmtlist RBRACKET
    (21) stmt -> . IF LPAREN cond RPAREN stmt end ELSE stmt end
    (22) stmt -> . IF LPAREN cond RPAREN stmt end
    (23) stmt -> . FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end
    (24) stmt -> . WHILE LPAREN cond RPAREN stmt end
    (25) stmt -> . PRINT prlist
    (26) stmt -> . PROCEDURE begin LPAREN arglist RPAREN
    (27) stmt -> . RETURN expr
    (28) stmt -> . type ID
    (29) stmt -> . expr
    (8) type -> . VOID
    (9) type -> . STRING
    (10) type -> . FLOAT
    (11) type -> . INT
    (37) expr -> . ID DEC
    (38) expr -> . ID INC
    (39) expr -> . DEC ID
    (40) expr -> . INC ID
    (41) expr -> . NOT expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr NE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr LE expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GE expr
    (49) expr -> . expr GT expr
    (50) expr -> . MINUS expr
    (51) expr -> . expr POWER expr
    (52) expr -> . expr MODULE expr
    (53) expr -> . expr DIVIDE expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr MINUS expr
    (56) expr -> . expr PLUS expr
    (57) expr -> . LPAREN expr RPAREN
    (58) expr -> . BLTIN LPAREN expr RPAREN
    (59) expr -> . ID LPAREN prlist RPAREN
    (60) expr -> . READ LPAREN ID RPAREN
    (61) expr -> . FUNCTION begin LPAREN arglist RPAREN
    (62) expr -> . assign
    (63) expr -> . ARG
    (64) expr -> . ID
    (65) expr -> . FLOATT
    (66) expr -> . INTEGER
    (12) assign -> . ID MODEQ expr
    (13) assign -> . ID DIVEQ expr
    (14) assign -> . ID MULEQ expr
    (15) assign -> . ID SUBEQ expr
    (16) assign -> . ID ADDEQ expr
    (17) assign -> . ID ASSIGN expr
    LBRACKET        shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    WHILE           shift and go to state 24
    PRINT           shift and go to state 25
    PROCEDURE       shift and go to state 26
    RETURN          shift and go to state 27
    VOID            shift and go to state 31
    STRING          shift and go to state 32
    FLOAT           shift and go to state 33
    INT             shift and go to state 34
    ID              shift and go to state 9
    DEC             shift and go to state 10
    INC             shift and go to state 11
    NOT             shift and go to state 12
    MINUS           shift and go to state 13
    LPAREN          shift and go to state 14
    BLTIN           shift and go to state 15
    READ            shift and go to state 16
    FUNCTION        shift and go to state 17
    ARG             shift and go to state 18
    FLOATT          shift and go to state 19
    INTEGER         shift and go to state 20

    stmt                           shift and go to state 170
    expr                           shift and go to state 75
    type                           shift and go to state 28
    assign                         shift and go to state 66

state 169

    (21) stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .
    NEWLINE         reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    RBRACKET        reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    LBRACKET        reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    IF              reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    FOR             reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    WHILE           reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    PRINT           reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    PROCEDURE       reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    RETURN          reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    VOID            reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    STRING          reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    FLOAT           reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    INT             reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    ID              reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    DEC             reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    INC             reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    NOT             reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    MINUS           reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    LPAREN          reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    BLTIN           reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    READ            reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    FUNCTION        reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    ARG             reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    FLOATT          reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    INTEGER         reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)
    ELSE            reduce using rule 21 (stmt -> IF LPAREN cond RPAREN stmt end ELSE stmt end .)


state 170

    (23) stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt . end
    (32) end -> .
    NEWLINE         reduce using rule 32 (end -> .)
    RBRACKET        reduce using rule 32 (end -> .)
    LBRACKET        reduce using rule 32 (end -> .)
    IF              reduce using rule 32 (end -> .)
    FOR             reduce using rule 32 (end -> .)
    WHILE           reduce using rule 32 (end -> .)
    PRINT           reduce using rule 32 (end -> .)
    PROCEDURE       reduce using rule 32 (end -> .)
    RETURN          reduce using rule 32 (end -> .)
    VOID            reduce using rule 32 (end -> .)
    STRING          reduce using rule 32 (end -> .)
    FLOAT           reduce using rule 32 (end -> .)
    INT             reduce using rule 32 (end -> .)
    ID              reduce using rule 32 (end -> .)
    DEC             reduce using rule 32 (end -> .)
    INC             reduce using rule 32 (end -> .)
    NOT             reduce using rule 32 (end -> .)
    MINUS           reduce using rule 32 (end -> .)
    LPAREN          reduce using rule 32 (end -> .)
    BLTIN           reduce using rule 32 (end -> .)
    READ            reduce using rule 32 (end -> .)
    FUNCTION        reduce using rule 32 (end -> .)
    ARG             reduce using rule 32 (end -> .)
    FLOATT          reduce using rule 32 (end -> .)
    INTEGER         reduce using rule 32 (end -> .)
    ELSE            reduce using rule 32 (end -> .)

    end                            shift and go to state 171

state 171

    (23) stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .
    NEWLINE         reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    RBRACKET        reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    LBRACKET        reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    IF              reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    FOR             reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    WHILE           reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    PRINT           reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    PROCEDURE       reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    RETURN          reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    VOID            reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    STRING          reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    FLOAT           reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    INT             reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    ID              reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    DEC             reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    INC             reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    NOT             reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    MINUS           reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    LPAREN          reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    BLTIN           reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    READ            reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    FUNCTION        reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    ARG             reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    FLOATT          reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    INTEGER         reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)
    ELSE            reduce using rule 23 (stmt -> FOR LPAREN cond SEMI cond SEMI cond RPAREN stmt end .)


Conflicts:

shift/reduce conflict for NEWLINE in state 5 resolved as shift
shift/reduce conflict for NEWLINE in state 7 resolved as shift
shift/reduce conflict for DEC in state 9 resolved as shift
shift/reduce conflict for INC in state 9 resolved as shift
shift/reduce conflict for LPAREN in state 9 resolved as shift
shift/reduce conflict for MINUS in state 75 resolved as shift
shift/reduce conflict for MINUS in state 81 resolved as shift
shift/reduce conflict for MINUS in state 136 resolved as shift
shift/reduce conflict for ELSE in state 156 resolved as shift